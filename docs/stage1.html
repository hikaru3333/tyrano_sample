<!DOCTYPE html>
<html>
  <head>
    <title>Tank</title>
    <style>
      /* Style for the stage pages */
      body {
        background-color: rgb(31, 14, 57); /* 背景色を設定 */
      }
      canvas {
        position: absolute;
        left: 50%;
        transform: translate(-50%, 0);
        border: 1px solid rgb(105, 58, 234); /* Canvasにボーダーを設定 */
      }
      .stage-page {
        text-align: center;
      }
      .textContainer {
        position: absolute;
        top: 670px; 
        right: 50px;
      }
      .bottonContainer {
        position: absolute;
        top: 690px;
        text-align: right;
      }
      h1 {
        color: rgb(225, 176, 176);
        font-size: 24px;
      }
      h2 {
        color: rgba(236, 184, 184, 0.481);
        font-size: 12px;
      }
      .button {
        display: inline-block;
        padding: 10px;
        background-color: midnightblue;
        color: white;
        cursor: pointer;
        border-radius: 5px;
        transition: color 0.3s ease;
      }
      .button:hover {
        color: #2f1144;
      }
      .button2 {
        display: none;
        padding: 10px;
        background-color: purple;
        color: white;
        cursor: pointer;
        border-radius: 5px;
        transition: color 0.3s ease;
      }
      .button2:hover {
        color: #2f1144;
      }
    </style>
  </head>
  <body>
    <div class="stage-page">
      <h1>1</h1>
      <h2>[w]:↑  [a]:←  [s]:↓  [d]:→  [ShiftLeft]:SHOT BULLET  [f]:SPECIAL MOVE</h2>
    </div>
    <div class="bottonContainer">
      <button id="button1" class="button">Return to Menu Page</button>
      <button id="button2" class="button2">Go to Stage 2</button>  
    </div>
    <canvas id="gameCanvas" width="610" height="490"></canvas>
    <canvas id="backgroundCanvas" width="610" height="490"></canvas>
    <canvas id="menuCanvas" width="610" height="600"></canvas>
    <script>
//canvas for players
const canvas = document.getElementById('gameCanvas');
document.body.appendChild(canvas);
const ctx = canvas.getContext('2d');
//canvas for backgraound
const backgroundCanvas = document.getElementById('backgroundCanvas');
const backctx = backgroundCanvas.getContext('2d');
//canvas for meny
const menuCanvas = document.getElementById('menuCanvas');
document.body.appendChild(menuCanvas);
const menuctx = menuCanvas.getContext('2d');
//get the location of button1
var button1 = document.getElementById("button1");
var button2 = document.getElementById("button2");

//※アイテム取得時のログ　過去ログ　システム選択　
//※ブロックにlist作ってそれぞれのhpをgenerateMapで格納し、hp=0で壊れる

//initial states
//player1
player1={
  x: 200,
  y: 400,
  radius: 20,
  speedx: 0,
  speedy: 2,
  accel: 0.1,
  angle: 0,
  length: 15,
  jump1: 2,
  jump2: 0,
  hp: 100,
  maxhp: 100,
  hpgain: 1/30,
  mp: 100,
  maxmp: 100,
  mpgain: 1/2,
  spe: 4.5,
  kill: 0,
  result: 0,
  taken: 0,
  headcolor: 'olive', //initial color
  bodycolor: 'darkolivegreen',
  type:0, //
  state:0, //link to EXP
  grade:1, //up grade limit
  grade1: 0, //hp
  grade2: 0, //hp+
  grade3: 0, //mp
  grade4: 0, //mp+
  grade5: 0, //atk
  grade6: 0, //a-spe
  grade7: 0, //spd
  drone:0, //noumber of drones
  expcap:100 
};
//Nplayer
nplayer={
  x: 100,
  y: 100,
  radius: 20,
  speedx: -2,
  speedy: 0,
  accel: 0.1,
  angle: 0,
  length: 15,
  jump1: 2,
  jump2: 0,
  hp: 50,
  mp: 100,
  headcolor: 'white',
  bodycolor: 'silver'
};
//bullet
blt = {
  x: 100,
  y: 100,
  radius: 10,
  speedx: 0,
  speedy: 0,
  f: 8,
  count: 0,
  damage: 2/3,
  delay: 30
};
//enemny
enm = {
  x: 100,
  y: 100,
  radius: 5,
  speedx: 0,
  speedy: 0,
  f: 8,
  count: 0,
  damage: 1
}
//biim
bim1 = {
  x: 100,
  y: 100,
  radius: 5,
  speedx: 10,
  speedy: 10,
  f: 10,
  t: 0,
  count: 0,
  damage: 1/2,
  delay: 30
}
bim2 = {
  x: 100,
  y: 100,
  radius: 5,
  speedx: 0,
  speedy: 0,
  f: 10,
  t: 0,
  count: 0,
  damage: 1/2
}
//rocket
rkt = {
  x: 100,
  y: 100,
  radius: 5,
  speedx: 2,
  speedy: 2,
  angle: 0,
  count1: 0,
  count2: 0,
  damage: 40,
  delay: 60 
}
//teleport
tele1 = {
  x: 100,
  y: 100,
  count: 0,
  in: 0,
  ed: false
}
//item
itm = {
  type: 0,
  x: 20,
  y: 20,
  speedx: 0,
  speedy: 0,
  count: 0
}
//thunder
rain = {
x1 : 0,
x2 : []
}
//goal
goal = {
  x:-100,
  y:0,
  n:0
}
//mine : 準備中
min = {
  x: 0,
  y: 0,
  damage: 50,
  count: 0,
  delay: 120,
}


//parameters
var stage = 1;
var gravity = 0.1;
var x_res = 0.2;
var t_count =0;
var limit = 1500;//second
var mapX = 0;
var t_3 = 0; //回復時に使用する現在時間　未実装
var ishoversound = 0; //sound用
var isfiresound = 0; //sound用
var ispause = 0; //psuseしているかどうか 
var ishpbar = 1; //hp,mpバーあり
var volume = 0.2; //音量調整
let isFunctionExecuted = true;//フラグリセット
const controller = {};
const BLOCK_SIZE = 39;
const BLOCK_GAP = 1;
const addhp = 10; //回復　未実装

// 弾幕の配列を初期化
let bullets = [];
let enemys = [];
let biim1s =[];
let biim2s =[];
let rockets = [];
let npcs = [];
let items = [];
let mines = [];


//for calculate process speed
var ps = 0;
var ps_true = 0;

//get map matrix ０：空白、１：破壊可、２：npc、３：item、４：goal、５：破壊不可、６：npcジェネレータ、７：裏２、８：裏１
const Matrix = [
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ,
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ,
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,6,1,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,2,6,1,0] ,
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,1,6] ,
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ,
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4] ,
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,1] ,
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ,
[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0] ,
[0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] ,
[3,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,2,0,2,0,0] ,
[1,1,5,5,5,5,5,5,5,5,1,1,1,1,1,1,1,1,1,1,5,5,5,5,5,5,1,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,1,1,1,1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,5,5,5,5,5,0,0,0,5,0,0,0,0,5,5,5,5,1,1,1,1] ,
[0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,1,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0] 
];
//Mapの天井地面背景の準備
let twrs=[];
const twrN=50;
for (var i = 0; i < twrN; i++){
  const ty=i/twrN;
  const tx=Math.random()*canvas.width*(1+3*ty);
  const clr=200*ty
  twrs.push({
    initialx: tx,
    x: tx,
    y: ty*canvas.height,
    dx: ty*canvas.width*3/4000,
    w0: Math.random(),
    w1: Math.random(),
    w2: Math.random(),
    color: `rgb(${clr}, ${clr}, ${clr})`
  });
}

//sound parameters
const audio_ctx = new AudioContext();
let audio_buffer ;
let audio_buffer_node ;
var gainNode = audio_ctx.createGain();
//load sounds
var bombsound = new Audio('sound/bomb1.mp3');
var cannonsound = new Audio('sound/cannon2.mp3');
var itemsound = new Audio('sound/power-up1.mp3');
var shotsound = new Audio('sound/shot1.mp3');
var breaksound = new Audio('sound/blow4.mp3');
var hit2sound = new Audio('sound/blow1.mp3');
var firesound = new Audio('sound/magic-flame1.mp3');
var boostsound = new Audio('sound/booster1.mp3');
var biimsound = new Audio('sound/beamgun2.mp3');
var warpsound = new Audio('sound/enemy-advent1.mp3');
var rocketsound = new Audio('sound/rocket-launcher1.mp3');
var hoversound = new Audio('sound/electric-fan-high1.mp3');
var landsound = new Audio('sound/landing1.mp3');
var hitsound = new Audio('sound/machine-hit3.mp3');
// 音源再生のために準備を行う
function changevolume(){
  //音量調整
  bombsound.volume = volume;
  cannonsound.volume = volume/2;
  itemsound.volume = volume/2;
  shotsound.volume = volume/2;
  breaksound.volume = volume;
  boostsound.volume = volume;
  biimsound.volume = volume;
  warpsound.volume = volume;
  rocketsound.volume = volume;
  hoversound.volume = volume;
  landsound.volume = volume/2;
  firesound.volume = volume;
  hitsound.volume = volume;
  hit2sound.volume = volume;
  //追加：web audio APIによるサウンド　テスト
  (async () => {
    const response = await fetch('sound/cannon2.mp3') // fetch で mp3 ファイルをダウンロードして ArrayBuffer を取得
    const response_buffer = await response.arrayBuffer();
    audio_buffer = await audio_ctx.decodeAudioData(response_buffer);// ArrayBuffer をデコードして AudioBuffer オブジェクトを取得
    gainNode.connect(audio_ctx.destination);
    gainNode.gain.value = volume/2;
    prepareAudioBufferNode(); // 初回再生のために準備を行う
  })();
}
function prepareAudioBufferNode() {
  audio_buffer_node = audio_ctx.createBufferSource();
  audio_buffer_node.buffer = audio_buffer;
  audio_buffer_node.connect(gainNode)
  //audio_buffer_node.connect(audio_ctx.destination);
}
changevolume()

// ランダムなRGB値を生成する関数
function getRandomColor() {
      const r = Math.floor(Math.random() * 256);
      const g = Math.floor(Math.random() * 256);
      const b = Math.floor(Math.random() * 256);
      return `rgb(${r}, ${g}, ${b})`;
    }

//Map構築
function drowMap(BLOCK_MATRIX){  
  //Map, Loop through the block matrix and draw blocks
  backctx.globalAlpha = 1;
  const gradient = backctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#2f1144');
    gradient.addColorStop(0.7, 'black');
    gradient.addColorStop(1, '#B09AEA');
    // グラデーションを背景に描画
    backctx.fillStyle = gradient;
    backctx.fillRect(0, 0, canvas.width, canvas.height);

  //buildings,ground,ceiling
  twrs.forEach(twr => {
    //move
    twr.x=twr.initialx-mapX*twr.dx;
    //draw
    const gradient = backctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#2f1144');
    gradient.addColorStop(0.7, twr.color);
    gradient.addColorStop(1, '#2f1144');
    backctx.fillStyle = gradient;
    backctx.fillRect(twr.x, canvas.height*2/3-twr.y*2/3, twr.y/10, twr.y);
    backctx.fillStyle = 'purple';
    backctx.fillRect(twr.x, canvas.height*2/3-twr.y*(2/3-twr.w0), twr.y/10, twr.y/100);
    backctx.fillRect(twr.x, canvas.height*2/3-twr.y*(2/3-twr.w1), twr.y/10, twr.y/100);
    backctx.fillRect(twr.x, canvas.height*2/3-twr.y*(2/3-twr.w2), twr.y/10, twr.y/100);
    //calculate process speed
    ps++;
  });  

  for (let row = 0; row < BLOCK_MATRIX.length; row++) {
    for (let col = 0; col < BLOCK_MATRIX[0].length; col++) {
      const blockX = col * (BLOCK_SIZE + BLOCK_GAP) - mapX;
      const blockY = row * (BLOCK_SIZE + BLOCK_GAP);
      if(blockX>-50 && blockY<canvas.width+50){
        if (BLOCK_MATRIX[row][col] === 1 && blockX<canvas.width+50 && blockX>-50) {
          backctx.globalAlpha = 1;
          backctx.fillStyle = 'gray';
          backctx.fillRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
        } 
        if (BLOCK_MATRIX[row][col] === 3 && blockX<canvas.width+50 && blockX>-50) {
          backctx.globalAlpha = 0.4;
          backctx.fillStyle = 'gray';
          backctx.fillRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
          //tank
          backctx.fillStyle = 'gray';
          backctx.fillRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
          backctx.fillStyle = 'silver';
          backctx.fillRect(blockX-player1.radius/4+BLOCK_SIZE/2, blockY-player1.radius/4+BLOCK_SIZE/2, player1.radius/2, player1.radius/2);
          backctx.fillStyle = 'gray';
          backctx.fillRect(blockX-player1.radius*3/4+BLOCK_SIZE/2, blockY+player1.radius/4+BLOCK_SIZE/2, player1.radius*3/2, player1.radius/2);
          //canond
          backctx.beginPath();
          backctx.moveTo(blockX+BLOCK_SIZE/2, blockY+BLOCK_SIZE/2);
          backctx.lineTo(blockX + player1.length+BLOCK_SIZE/2, blockY+BLOCK_SIZE/2);
          backctx.stroke();
          //type
          backctx.globalAlpha = 1;
          backctx.fillStyle = 'white';
          backctx.font = '24px Arial';
          if(player1.type === 0){
            backctx.fillText('1', blockX+BLOCK_SIZE/3, blockY+BLOCK_SIZE/3*2);
          }
          else if(player1.type === 1){
            backctx.fillText('2', blockX+BLOCK_SIZE/3, blockY+BLOCK_SIZE/3*2);
          }
          else if(player1.type === 2){
            backctx.fillText('3', blockX+BLOCK_SIZE/3, blockY+BLOCK_SIZE/3*2);
          }
          else{
            backctx.fillText('人', blockX+BLOCK_SIZE/4, blockY+BLOCK_SIZE/3*2);
          }
        } 
        if (BLOCK_MATRIX[row][col] === 5 && blockX<canvas.width+50 && blockX>-50) {
          backctx.globalAlpha = 1;
          backctx.fillStyle = 'silver';
          backctx.fillRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
        }     
        if (BLOCK_MATRIX[row][col] === 6 && blockX<canvas.width+50 && blockX>-50) {
        backctx.globalAlpha = 0.1;
        backctx.fillStyle = 'red';
        backctx.fillRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
      }
      }
    }
  }
  backctx.beginPath();
  backctx.arc(1, 1, 1, 0,Math.PI * 2);
  backctx.closePath();
  backctx.fill();
}

//描写と動作とnpc動作アルゴリズム
function drawPlayers(){
  //back of hp, mp
  ctx.globalAlpha = 1/4;
  ctx.fillStyle = 'pink';
  ctx.fillRect(player1.x-player1.radius/2, player1.y-20, player1.radius, 4);
  ctx.fillStyle = 'yellow';
  ctx.fillRect(player1.x-player1.radius/2, player1.y-15, player1.radius, 4);
  ctx.globalAlpha = 1;
  //bar of hp, mp
  ctx.fillStyle = 'green';
  ctx.fillRect(player1.x-player1.radius/2, player1.y-19, player1.hp/player1.maxhp*player1.radius, 2);
  ctx.fillStyle = 'blue';
  ctx.fillRect(player1.x-player1.radius/2, player1.y-14, player1.mp/player1.maxmp*player1.radius, 2);
  //draw player1
  if(player1.type==-1){
    ctx.strokeStyle = player1.headcolor;
    ctx.lineWidth = 3;
    //leg
    if(Math.abs(player1.speedx)<1/2){
      ctx.beginPath();
      ctx.moveTo(player1.x, player1.y+7);
      ctx.lineTo(player1.x, player1.y+15);
      ctx.closePath();
      ctx.stroke();
    }
    else{
      ctx.beginPath();
      ctx.moveTo(player1.x, player1.y+7);
      ctx.lineTo(player1.x+3*Math.cos(t_count/10), player1.y+14-1*Math.cos(t_count/5));
      ctx.closePath();
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(player1.x, player1.y+7);
      ctx.lineTo(player1.x-3*Math.cos(t_count/10), player1.y+14-1*Math.cos(t_count/5));
      ctx.closePath();
      ctx.stroke();
    }
    //back
    ctx.fillStyle = player1.headcolor;
    ctx.fillRect(player1.x-4.5, player1.y,5,8);
    //body
    ctx.fillStyle = player1.bodycolor;
    ctx.fillRect(player1.x-2.5, player1.y-4.5,5,5);
    ctx.fillRect(player1.x-3, player1.y+1,6,8);
    //face
    ctx.fillStyle = "#EEC8B4";
    ctx.fillRect(player1.x, player1.y-3,2.5,2.5);
    //arm
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(player1.x-0.5, player1.y+1.5);
    ctx.lineTo(player1.x+Math.cos(player1.angle)*7, player1.y+2+Math.sin(player1.angle)*6);
    ctx.closePath();
    ctx.stroke();
    //gun
    ctx.lineWidth = 1;
    ctx.beginPath();
    if(player1.grade==1){
      ctx.strokeStyle = "black";
      ctx.moveTo(player1.x+Math.cos(player1.angle+0.2)*7, player1.y+2+Math.sin(player1.angle+0.2)*6);
      ctx.lineTo(player1.x+Math.cos(player1.angle-0.2)*7, player1.y+2+Math.sin(player1.angle-0.2)*6);
      ctx.lineTo(player1.x+Math.cos(player1.angle-0.1)*11, player1.y+2+Math.sin(player1.angle-0.1)*10);
    }
    else if(player1.grade==2){
      ctx.strokeStyle = "black";
      ctx.moveTo(player1.x+Math.cos(player1.angle-0.1)*10, player1.y+2+Math.sin(player1.angle-0.1)*9);
      ctx.lineTo(player1.x+Math.cos(player1.angle+0.2)*7, player1.y+2+Math.sin(player1.angle+0.2)*6);
      ctx.lineTo(player1.x+Math.cos(player1.angle-0.2)*7, player1.y+2+Math.sin(player1.angle-0.2)*6);
      ctx.lineTo(player1.x+Math.cos(player1.angle-0.08)*14, player1.y+2+Math.sin(player1.angle-0.08)*13);
    }
    else{
      ctx.strokeStyle = "red";
      ctx.moveTo(player1.x+1, player1.y-2);
      ctx.lineTo(player1.x+1.5, player1.y-2);
      ctx.closePath();
      ctx.stroke();
      ctx.beginPath();
      ctx.strokeStyle = `rgb(${player1.grade*10},0,0)`;
      ctx.moveTo(player1.x+Math.cos(player1.angle-0.1)*10, player1.y+2+Math.sin(player1.angle-0.1)*9);
      ctx.lineTo(player1.x+Math.cos(player1.angle+0.2)*7, player1.y+2+Math.sin(player1.angle+0.2)*6);
      ctx.lineTo(player1.x+Math.cos(player1.angle-0.2)*7, player1.y+2+Math.sin(player1.angle-0.2)*6);
      ctx.lineTo(player1.x+Math.cos(player1.angle-0.08)*14, player1.y+2+Math.sin(player1.angle-0.08)*13);
      ctx.lineTo(player1.x+Math.cos(player1.angle+0.1)*11, player1.y+2+Math.sin(player1.angle+0.1)*10);
    }
    ctx.closePath();
    ctx.stroke();
    //hand
    ctx.fillRect(player1.x-1+Math.cos(player1.angle)*7,player1.y+1+Math.sin(player1.angle)*6,2,2);

  }
  //Tank
  else{
    ctx.fillStyle = player1.headcolor;
    ctx.fillRect(player1.x-player1.radius/4, player1.y-player1.radius/4, player1.radius/2, player1.radius/2);
    ctx.fillStyle = player1.bodycolor;
    ctx.fillRect(player1.x-player1.radius*3/4, player1.y+player1.radius/4, player1.radius*3/2, player1.radius/2);
    //body
    ctx.strokeStyle = `black`
    ctx.fillStyle = player1.headcolor;
    ctx.beginPath();
    ctx.arc(player1.x-player1.radius/2-1, player1.y+player1.radius/2+2, 4, Math.PI/2,-Math.PI/2);
    ctx.fill();
    ctx.lineTo(player1.x+player1.radius/2+1, player1.y+player1.radius/2-2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(player1.x+player1.radius/2+1, player1.y+player1.radius/2+2, 4, -Math.PI/2,Math.PI/2);
    ctx.fill();
    ctx.lineTo(player1.x-player1.radius/2-1, player1.y+player1.radius/2+6);
    ctx.stroke();
    ctx.fillStyle = player1.bodycolor;
    //canon
    if(player1.grade>1){
      if(player1.grade==2){
        ctx.beginPath();
        ctx.arc(player1.x, player1.y, 4, 0,Math.PI * 2);
        ctx.fill();
        ctx.closePath();
        ctx.strokeStyle = `rgb(100,50,50)`
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(player1.x, player1.y);
        ctx.lineTo(player1.x + Math.cos(player1.angle) * player1.length*0.8, player1.y + Math.sin(player1.angle) * player1.length*0.8);
        ctx.stroke();
        ctx.strokeStyle = `black`
      }
      else if(player1.grade==3){
        ctx.beginPath();
        ctx.arc(player1.x, player1.y, 4, player1.angle+Math.PI/2,player1.angle-Math.PI/2);
        ctx.fill();
        ctx.closePath();
        ctx.stroke();
        ctx.strokeStyle = `rgb(30,0,0)`
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(player1.x -Math.sin(player1.angle)*2.5, player1.y +Math.cos(player1.angle)*2.5);
        ctx.lineTo(player1.x -Math.sin(player1.angle)*2.5+ Math.cos(player1.angle) * player1.length*0.7, player1.y +Math.cos(player1.angle)*2.5+ Math.sin(player1.angle) * player1.length*0.7);
        ctx.stroke(); 
      }
      else{
        ctx.beginPath();
        ctx.arc(player1.x, player1.y, 4, player1.angle+Math.PI/2,player1.angle-Math.PI/2);
        ctx.fill();
        ctx.closePath();
        ctx.stroke();
        ctx.strokeStyle = `rgb(${player1.grade*10},0,0)`
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        sin=Math.sin(player1.angle)*2.5;
        cos=Math.cos(player1.angle)*2.5;
        ctx.moveTo(player1.x -sin, player1.y +cos);
        ctx.lineTo(player1.x -sin+ Math.cos(player1.angle) * player1.length*0.8, player1.y +cos+ Math.sin(player1.angle) * player1.length*0.8);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(player1.x+sin, player1.y-cos);
        ctx.lineTo(player1.x+sin + Math.cos(player1.angle) * player1.length*0.6, player1.y-cos + Math.sin(player1.angle) * player1.length*0.6);
        ctx.stroke();
        //for calculate process speed
        ps++;
      }
    }
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(player1.x, player1.y);
    ctx.lineTo(player1.x + Math.cos(player1.angle) * player1.length, player1.y + Math.sin(player1.angle) * player1.length);
    ctx.stroke();
  }
  //drones
  if(player1.drone>0){
    ctx.strokeStyle = `black`
    ctx.fillStyle = player1.headcolor;
    for (var i = 0; i < player1.drone+1; i++){
      sin=Math.sin(Math.PI/player1.drone*i*2+t_count/100)
      cos=Math.cos(Math.PI/player1.drone*i*2+t_count/100)
      ctx.beginPath();
      ctx.arc(player1.x-sin*20, player1.y+cos*10, 3, player1.angle+Math.PI/2,player1.angle-Math.PI/2);
      ctx.fill();
      ctx.moveTo(player1.x-sin*20, player1.y+cos*10);
      ctx.lineTo(player1.x-sin*20+ Math.cos(player1.angle)*7, player1.y+cos*10+ Math.sin(player1.angle)*7);
      ctx.closePath();
      ctx.stroke();
      //for calculate process speed
      ps++;
    }
  }

  //抵抗
  if(player1.speedx>0.1){
      player1.speedx-=player1.speedx/3*x_res;
      if(player1.speedx>player1.spe){
      player1.speedx-=10*x_res;
      }
  }
  else if(player1.speedx<-0.1){
      if(player1.speedx<-player1.spe){
      player1.speedx+=10*x_res;
      }
      player1.speedx-=player1.speedx/3*x_res;
  }
  else{player1.speedx=0}
  //画面移動
  if(player1.x <= canvas.width/3){
    player1.x = canvas.width/3
    mapX += player1.speedx;
    drowMap(Matrix)
  }
  else if(player1.x >= canvas.width*2/3){
    player1.x = canvas.width/3*2
    mapX += player1.speedx;
    drowMap(Matrix)
  }
  else{
    //player移動
    player1.x += player1.speedx;
  }

  //player移動
  player1.y += player1.speedy;
  //重力
  player1.speedy += gravity;
  //for calculate process speed
  ps++;
}
function drawNplayer(){
  npcs.forEach(npc => {
    npc.x=npc.initialx-mapX
    if(npc.x>-20 && npc.x<canvas.width+20){
      //draw non player
      ctx.globalAlpha = 1/4;
      ctx.fillStyle = 'pink';
      ctx.fillRect(npc.x-npc.radius/2, npc.y-15, npc.radius, 4);
      ctx.globalAlpha = 1;
      ctx.fillStyle = 'green';
      ctx.fillRect(npc.x-npc.radius/2, npc.y-14, npc.hp/nplayer.hp*npc.radius, 2);
      ctx.fillStyle = nplayer.headcolor;
      ctx.fillRect(npc.x-npc.radius/4, npc.y-npc.radius/4, npc.radius/2, npc.radius/2);
      ctx.fillStyle = nplayer.bodycolor;
      ctx.fillRect(npc.x-npc.radius*3/4, npc.y+npc.radius/4, npc.radius*3/2, npc.radius/2);
      //body
      ctx.fillStyle = nplayer.headcolor;
      ctx.beginPath();
      ctx.arc(npc.x-npc.radius/2-1, npc.y+npc.radius/2+2, 4, 0,Math.PI*2);
      ctx.arc(npc.x+npc.radius/2+1, npc.y+npc.radius/2+2, 4, 0,Math.PI*2);
      ctx.fill();
      //canon
      ctx.strokeStyle = `black`
      ctx.beginPath();
      ctx.moveTo(npc.x, npc.y);
      ctx.lineTo(npc.x + Math.cos(npc.angle) * nplayer.length, npc.y + Math.sin(npc.angle) * nplayer.length);
      ctx.stroke();  
      //for calculate process speed
      ps++;
    }
  });
  npcs = npcs.filter(npc => {
    //アルゴリズム
    var dx = Math.abs(npc.x-player1.x);
    var dy = Math.abs(npc.y-player1.y)
    if(dx<300 && dy<500){
      if(dx>150){
        npc.accelx = (player1.x-npc.x)/dx/10
      }
      else if(dy>50){
        if(player1.x<npc.x){
          npc.angle = Math.PI+Math.atan((player1.y-npc.y)/(player1.x-npc.x));
        }
        else{
          npc.angle = Math.atan((player1.y-npc.y)/(player1.x-npc.x));
        }
        //biim
        bim2.t = 150
        if(npc.count>60){
            bim2.x = npc.x + 25*Math.cos(npc.angle);
            bim2.y = npc.y + 25*Math.sin(npc.angle);
          for (var i = 0; i < 20; i++) {
            bim2.radius = i/5+1
            bim2.speedx = (i/20+2)*Math.cos(npc.angle);
            bim2.speedy = (i/20+2)*Math.sin(npc.angle);
            shootBiim2();
          }
          shotsound.pause();
          shotsound.currentTime = 0; // 再生位置をリセット
          shotsound.play(); // サウンドを再生
          npc.count=0;
          npc.speedx -= Math.cos(npc.angle)/6;
          npc.speedy -= Math.sin(npc.angle)/6;
        }
        else{
          npc.count+=1;
          ctx.beginPath();
          ctx.fillStyle = nplayer.headcolor;
          ctx.globalAlpha = npc.count/60;
          ctx.arc(npc.x + 25*Math.cos(npc.angle), npc.y + 25*Math.sin(npc.angle), npc.count/12, 0,Math.PI * 2);
          ctx.fill();
          ctx.closePath();
          ctx.globalAlpha = 1;
        }
      }
      //cannon
      if(dy<50){
        var vy = 3.5;
        var k = 71
        var vx = (npc.x-player1.x)/k - player1.speedx/4
        if(player1.x<npc.x){
          npc.angle = Math.PI+Math.atan(vy/vx);
        }
        else{
          npc.angle = Math.atan(vy/vx);
        }
        if(npc.count>60){
            enm.x = npc.x;
            enm.y = npc.y;
            enm.radius = 4
            enm.speedx = -vx;
            enm.speedy = -vy;
          for (var i = 0; i < 10; i++) {
            shootEnemy();
          }
          cannonsound.pause();
          cannonsound.currentTime = 0; // 再生位置をリセット
          cannonsound.play(); // サウンドを再生
          npc.count=0;
          npc.speedx -= Math.cos(npc.angle)/6;
          npc.speedy -= Math.sin(npc.angle)/6;
        }
        else{
          npc.count+=1;
        }
      }
    }
    //player移動
    npc.initialx += npc.speedx;
    npc.speedx += npc.accelx;
    npc.y += npc.speedy;
    mapX
    //重力
    npc.speedy += gravity;
    //抵抗
    if(npc.speedx>0.3){
      npc.speedx*=0.8
    }
    else if(npc.speedx<-0.3){
      npc.speedx*=0.8;
    }
  return npc.x > -10 && npc.x < 4000 && npc.y > -10 && npc.y < canvas.height+10;
  });
}
function drawBullet(){
  ctx.fillStyle = player1.headcolor;
  ctx.globalAlpha = 0.2;
  bullets.forEach(bullet => {
    bullet.x=bullet.initialx-mapX
    bullet.hp += 1;
    ctx.beginPath();
    ctx.arc(bullet.x, bullet.y, bullet.width, 0,Math.PI * 2);
    ctx.fill();
    ctx.closePath();
    //for calculate process speed
    ps++;
  });
  ctx.globalAlpha = 1;
  // 弾幕を移動
  bullets = bullets.filter(bullet => {
    bullet.speedY += gravity;
    bullet.initialx += bullet.speedX;
    bullet.y += bullet.speedY;
  return bullet.x > -30 && bullet.x < canvas.width+30 && bullet.y > 0 && bullet.y < canvas.height;
  }); 
}
function drawEnemy(){
  ctx.fillStyle = nplayer.headcolor;
    ctx.globalAlpha = 0.2;
    enemys.forEach(enemy => {
      enemy.x=enemy.initialx-mapX
      enemy.hp += 1;
      ctx.beginPath();
      ctx.arc(enemy.x, enemy.y, enemy.width, 0,Math.PI * 2);
      ctx.fill();
      ctx.closePath();
    //for calculate process speed
    ps++;
    });
    ctx.globalAlpha = 1;
  // 弾幕を移動
  enemys = enemys.filter(enemy => {
    enemy.speedY += gravity;
    enemy.initialx += enemy.speedX;
    enemy.y += enemy.speedY;
  return enemy.x > 0 && enemy.x < canvas.width && enemy.y > 0 && enemy.y < canvas.height;
  }); 
}
function drawBiim(){
  ctx.fillStyle = player1.headcolor;
  ctx.globalAlpha = 0.2;
  biim1s.forEach(biim1 => {
    biim1.x=biim1.initialx-mapX;
    ctx.beginPath();
    ctx.arc(biim1.x, biim1.y, biim1.width, 0,Math.PI * 2);
    ctx.fill();
    ctx.closePath();
    //for calculate process speed
    ps++;
  });
  ctx.globalAlpha = 1;
  biim1s = biim1s.filter(biim1 => {
    biim1.initialx += biim1.speedX;
    biim1.y += biim1.speedY;
    return biim1.x > -30 && biim1.x < canvas.width+30 && biim1.y > 0 && biim1.y < canvas.height;
});
  ctx.fillStyle = nplayer.headcolor;
  ctx.globalAlpha = 0.2;
  biim2s.forEach(biim2 => {
    biim2.x=biim2.initialx-mapX;
    ctx.beginPath();
    ctx.arc(biim2.x, biim2.y, biim2.width, 0,Math.PI * 2);
    ctx.fill();
    ctx.closePath();
    //for calculate process speed
    ps++;
  });
  ctx.globalAlpha = 1;
  biim2s = biim2s.filter(biim2 => {
    biim2.initialx += biim2.speedX;
    biim2.y += biim2.speedY;
    return biim2.x > 0 && biim2.x < canvas.width+10 && biim2.y > 0 && biim2.y < canvas.height;
  });
}
function drawRocket(){
  ctx.fillStyle = 'gray'; 
  ctx.globalAlpha = 0.4; 
  ctx.strokeStyle = 'black'
  rockets.forEach(rocket => {
    rocket.x=rocket.initialx-mapX;
    ctx.moveTo(rocket.x,rocket.y);
    ctx.lineTo(rocket.x-2*rkt.radius*Math.cos(rocket.angle) ,rocket.y-2*rkt.radius*Math.sin(rocket.angle));
    ctx.lineTo(rocket.x-2*rkt.radius*Math.cos(rocket.angle+Math.PI/6) ,rocket.y-2*rkt.radius*Math.sin(rocket.angle+Math.PI/6));
    ctx.lineTo(rocket.x+2*rkt.radius*Math.cos(rocket.angle-Math.PI/6) ,rocket.y+2*rkt.radius*Math.sin(rocket.angle-Math.PI/6));
    ctx.lineTo(rocket.x+3*rkt.radius*Math.cos(rocket.angle) ,rocket.y+3*rkt.radius*Math.sin(rocket.angle));
    ctx.lineTo(rocket.x+2*rkt.radius*Math.cos(rocket.angle+Math.PI/6) ,rocket.y+2*rkt.radius*Math.sin(rocket.angle+Math.PI/6));
    ctx.lineTo(rocket.x-2*rkt.radius*Math.cos(rocket.angle-Math.PI/6) ,rocket.y-2*rkt.radius*Math.sin(rocket.angle-Math.PI/6));
    ctx.lineTo(rocket.x-2*rkt.radius*Math.cos(rocket.angle) ,rocket.y-2*rkt.radius*Math.sin(rocket.angle));
    ctx.closePath();
    ctx.fill();
    ctx.stroke()
    //for calculate process speed
    ps++;
  });
  ctx.globalAlpha = 1;
  // 弾幕を移動
  rockets = rockets.filter(rocket => {
    rocket.initialx += rocket.speedX;
    rocket.y += rocket.speedY;
    //画面外ループしない
  return rocket.x > -100 && rocket.x < canvas.width+100 && rocket.y > -100 && rocket.y < canvas.height+100;
  }); 
}
function drawItem(){
  //描画
  items.forEach(item => {
    item.x=item.initialx-mapX;
    //
    if(item.type == 0){
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = 'black';
      ctx.fillRect(item.x, item.y, BLOCK_SIZE/2, BLOCK_SIZE/2);
      ctx.fillStyle = 'white';
      ctx.font = '8px Arial';
      ctx.fillText(' +1 ',item.x, item.y+BLOCK_SIZE/4);
      ctx.fillText('drone',item.x, item.y+16);
    }
    if(item.type == 1){
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = 'green';
      ctx.fillRect(item.x, item.y, BLOCK_SIZE/2, BLOCK_SIZE/2);
      ctx.fillStyle = 'white';
      ctx.font = '10px Arial';
      ctx.fillText('+50',item.x, item.y+BLOCK_SIZE/3);     
    }
    if(item.type == 2){
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = 'yellow';
      ctx.beginPath();
      ctx.arc(item.x+BLOCK_SIZE/4, item.y+BLOCK_SIZE/4, 10, 0,Math.PI * 2);
      ctx.fill();
      ctx.closePath();
      ctx.fillStyle = 'white';
      ctx.font = '12px Arial';
      ctx.fillText('+10',item.x, item.y+14);  
    }
  });
  // 移動と削除
  items = items.filter(item => {
    item.initialx += item.speedx;
    item.y += item.speedy;
    //for calculate process speed
    ps++;
    //画面外ループしない
  return item.x > -100 && item.x < canvas.width+100 && item.y > -100 && item.y < canvas.height+100;
  }); 
}
function drawMine(){
  //描画
  mines.forEach(mine => {
    mine.x=mine.initialx-mapX;
    ctx.globalAlpha = 0.6;
    ctx.beginPath();
    ctx.fillStyle = 'black';
    ctx.arc(mine.x, mine.y, 5, Math.PI, 0);
    ctx.fill();
    ctx.closePath();
  });
  // 移動と削除
  mines = mines.filter(mine => {
    //for calculate process speed
    ps++;
    //画面外ループしない
  return mine.x > -100 && mine.x < canvas.width+100 && mine.y > -100 && mine.y < canvas.height+100;
  }); 
}

//goalの描画
function drawgoal(){
  ctx.globalAlpha = 0.2;
  ctx.fillStyle=getRandomColor();
  ctx.beginPath();
  ctx.arc(goal.x + BLOCK_SIZE/2, goal.y + BLOCK_SIZE/2, t_count%30/2, 0,Math.PI * 2);
  ctx.fill();
  ctx.closePath();
  ctx.globalAlpha = 0.5;
  ctx.fillStyle = 'white';
  ctx.font = '10px Arial';
  ctx.fillText('↓HERE↓',goal.x, goal.y);
  for (var i = 0; i < 10; i++) {
    ctx.beginPath();
    ctx.arc(goal.x + BLOCK_SIZE/2 + (t_count%40/2)*Math.cos(i*Math.PI/5+t_count/10), goal.y + BLOCK_SIZE/2 + (t_count%40/2)*Math.sin(i*Math.PI/5+t_count/10), t_count%40/10, 0,Math.PI * 2);
    ctx.fill();
    ctx.closePath();
    //for calculate process speed
    ps++;
  }
}


//ギミック
function Rain(t){  
  //for calculate process speed
  ps++;
  if(t_count > t*60 && t_count < (t+30)*60){
    ctx.fillStyle = 'black';
    ctx.globalAlpha = 0.5-Math.abs(t+15-t_count/60)/30;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    //rain
    if(Math.random()<0.1){
      blt.x = Math.random()*canvas.width;
      blt.y = 120;
      blt.radius = 3
      blt.speedx = 0;
      blt.speedy = 0;
      shootBullet();
      enm.x = Math.random()*canvas.width;
      enm.y = 120;
      enm.radius = 3
      enm.speedx = 0;
      enm.speedy = 0;
      shootEnemy();  
    }
    //thunder
    if(t_count > (t+13)*60 && t_count < (t+17)*60){
      //draw, damage for players
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = 'orange';
      ctx.font = '50px Arial';
      ctx.fillText("!CAUTION!", canvas.width/2-100, canvas.height/2);
      if(t_count > t*60+33*30){
        if(t_count==t*60+991){
          biimsound.pause();
          biimsound.currentTime = 0; // 再生位置をリセット
          biimsound.play(); // サウンドを再生
        }
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        ctx.globalAlpha = 0.5;
        ctx.fillRect(rain.x1-5-mapX, 0, 10, canvas.height);
        ctx.fillStyle = 'yellow';
        ctx.fillRect(rain.x1-10-mapX, 0, 20, canvas.height);
        if(player1.x+player1.radius/2>rain.x1-10-mapX && player1.x-player1.radius/2<rain.x1+10-mapX){
          player1.hp-=10;
          player1.result+=10;
        }
        /* 雲の描画　不要
        for (let i = 0; i < rain.x2.length; i++){
          ctx.globalAlpha = 0.1;
          ctx.fillStyle = 'white';
          ctx.fillRect(rain.x2-5, 0, 10, canvas.height);
          ctx.fillStyle = 'yellow';
          ctx.fillRect(rain.x2-10, 0, 20, canvas.height);
          npcs.forEach((npc, npcIndex) => {
            if(npc.x+npc.radius/2>rain.x2[i]-10 && npc.x-npc.radius/2<rain.x2[i]+10){
              npc.hp-=5;
            }
          });
        }
        */
      }
      else if(t_count < t*60+31*30) {
        ctx.globalAlpha = 0.1;
        rain.x1 = player1.x+mapX;
        ctx.fillStyle = 'white';
        ctx.fillRect(rain.x1-5-mapX, 0, 10, canvas.height);
        ctx.fillStyle = 'yellow';
        ctx.fillRect(rain.x1-2-mapX, 0, 4, canvas.height);
        /*　npcに雷当たるやつ
        npcs.forEach((npc, npcIndex) => {
          rain.x2.push(npc.x);
        });
        for (let i = 0; i < rain.x2.length; i++){
          ctx.fillStyle = 'white';
          ctx.fillRect(rain.x2[i]-5, 0, 10, canvas.height);
          ctx.fillStyle = 'yellow';
          ctx.fillRect(rain.x2[i]-2, 0, 4, canvas.height);
        }
        */
      }
      else{
        ctx.fillStyle = 'yellow';
        ctx.fillRect(rain.x1-2-mapX, 0, 4, canvas.height);
        /* npc用
        for (let i = 0; i < rain.x2.length; i++){
          ctx.fillRect(rain.x2[i]-2, 0, 4, canvas.height);
        }
        */
      }
    }
  }
}
function canon(t){
  if(t_count>t*60 && t_count<(t+10)*60 && Math.random()<1/60){
    const y=canvas.height*Math.random();
    const dx=player1.x+5-canvas.width;
    const dy=player1.y-y;
    const l=(dx**2+dy**2)**(1/2)
    bim2.t = 150
    for (var i = 0; i < 20; i++) {
      bim2.x = canvas.width-5;
      bim2.y = y;
      bim2.radius = (25/(i+1))**(1/2)
      bim2.speedx = (i/4+5)*dx/l
      bim2.speedy = (i/4+5)*dy/l
      shootBiim2();
    }
  }
}

//generate non player
function generateNplayer(){
  npcs.push({
    initialx: nplayer.x+mapX,
    x: nplayer.x,
    y: nplayer.y,
    radius: nplayer.radius,
    speedx: nplayer.speedx,
    speedy: nplayer.speedy,
    accelx: 0,
    hp: nplayer.hp,
    count: 0,
    angle: 0
  });
}

//generate item
function generateItem(){
  items.push({
    type: itm.type,
    initialx: itm.x+mapX,
    x: itm.x,
    y: itm.y,
    speedx: itm.speedx,
    speedy: itm.speedy,
    count: itm.count
  });
}
//shoot 弾等の生成
function shootBullet(){            
  bullets.push({
    initialx:blt.x+mapX,
    x: blt.x,
    y: blt.y,
    width: blt.radius,
    speedX: blt.speedx,
    speedY: blt.speedy,
    hp: 0
  });
};
function shootEnemy(){            
  enemys.push({
    initialx:enm.x+mapX,
    x: enm.x,
    y: enm.y,
    width: enm.radius,
    speedX: enm.speedx,
    speedY: enm.speedy,
    hp: 0
  });
};
function shootBiim1(){
  biim1s.push({
    initialx:bim1.x+mapX,
    x: bim1.x,
    y: bim1.y,
    width: bim1.radius,
    speedX: bim1.speedx,
    speedY: bim1.speedy,
    hp:0
})};
function shootBiim2(){
  biim2s.push({
    initialx:bim2.x+mapX,
    x: bim2.x,
    y: bim2.y,
    width: bim2.radius,
    speedX: bim2.speedx,
    speedY: bim2.speedy,
    hp:0
  })};
function shootRocket(){
  rockets.push({
    initialx:rkt.x+mapX,
    x: rkt.x,
    y: rkt.y,
    speedX: rkt.speedx,
    speedY: rkt.speedy,
    angle: rkt.angle,
    hp: 20
  })};
function shootMine(){
  mines.push({
    initialx: min.x+mapX,
    x: min.x,
    y: min.y,
    hp: 0
  })};

//跳ね返りblock player当たり判定
function blockCollision(BLOCK_MATRIX){ //bullet and enemy are included
  for (let row = 0; row < BLOCK_MATRIX.length; row++) {
    const rowLength = BLOCK_MATRIX[row].length;
    for (let col = 0; col < rowLength; col++) {
      const blockX = col * (BLOCK_SIZE + BLOCK_GAP) - mapX;
      const blockY = row * (BLOCK_SIZE + BLOCK_GAP);
      if(blockX>-150 && blockY<canvas.width+150){
        if (BLOCK_MATRIX[row][col] === 1 && blockX<canvas.width+150 && blockX>-100){
          //player1跳ね返り
          if(player1.x + player1.radius/4 > blockX && player1.x - player1.radius/4< blockX + BLOCK_SIZE){
            if(player1.y + player1.radius*3/4 > blockY && player1.y < blockY + BLOCK_SIZE/4){
              if(player1.speedy>0.2){
                ishoversound=0;
                hoversound.pause();
                landsound.pause();
                landsound.currentTime = 0; // 再生位置をリセット
                landsound.play(); // サウンドを再生
              }
              player1.speedy = 0;
              player1.y=blockY - player1.radius*3/4;
              if(controller['KeyW'] == false){
                player1.jump1=2; 
                player1.jump2=0;
              }
            }
          }//地面
          if(player1.x + player1.radius/4 > blockX && player1.x - player1.radius/4< blockX + BLOCK_SIZE){
            if(player1.y > blockY && player1.y - player1.radius/4 < blockY + BLOCK_SIZE){
              player1.speedy = (blockY + BLOCK_SIZE - player1.y + player1.radius/4)*1;
            }
          }//天井
          if(player1.y + player1.radius/2 > blockY && player1.y < blockY + BLOCK_SIZE){
            if(player1.x + player1.radius/2 > blockX && player1.x < blockX + BLOCK_SIZE/3){
              player1.speedx *= -0.8;
              player1.x=blockX - player1.radius/2;
            }     
          }//左
          if(player1.y + player1.radius/2> blockY && player1.y < blockY + BLOCK_SIZE){
            if(player1.x > blockX + BLOCK_SIZE*2/3 && player1.x - player1.radius/2 < blockX + BLOCK_SIZE){
              player1.speedx *= -0.8;
              player1.x=blockX + BLOCK_SIZE + player1.radius/2;
            }     
          }//右       
          //for calculate process speed
          ps++;
          //npc跳ね返り
          npcs.forEach((npc, npcIndex) => {
            if(npc.x>-100 && npc.x<canvas.width+100){
              if(npc.x + npc.radius/4 > blockX && npc.x - npc.radius/4< blockX + BLOCK_SIZE){
                if(npc.y + npc.radius*3/4 > blockY && npc.y < blockY + BLOCK_SIZE/4){
                  npc.speedy *= 0;
                  npc.y=blockY - npc.radius*3/4;
                  if(controller['ArrowUp'] == false){
                    npc.jump1=2; 
                    npc.jump2=0;
                  }
                }
              }//地面
              if(npc.x + npc.radius/4 > blockX && npc.x - npc.radius/4< blockX + BLOCK_SIZE){
                if(npc.y > blockY && npc.y - npc.radius/4 < blockY + BLOCK_SIZE){
                  npc.speedy = (blockY + BLOCK_SIZE - npc.y + npc.radius/4)*1;
                }
              }//天井
              if(npc.y + npc.radius/2 > blockY && npc.y < blockY + BLOCK_SIZE){
                if(npc.x + npc.radius/2 > blockX && npc.x < blockX + BLOCK_SIZE/3){
                  npc.speedx *= -0.8;
                  npc.initialx=npc.initialx-1;
                }     
              }//左
              if(npc.y + npc.radius/2> blockY && npc.y < blockY + BLOCK_SIZE){
                if(npc.x > blockX + BLOCK_SIZE*2/3 && npc.x - npc.radius/2 < blockX + BLOCK_SIZE){
                  npc.speedx *= -0.8;
                  npc.initialx=npc.initialx+1;
                }     
              }//右
              //for calculate process speed
              ps++;
            }
          });   
          //Bullet
          bullets.forEach((bullet, bulletIndex) => {
            if(bullet.x + bullet.width/4 > blockX && bullet.x - bullet.width/4< blockX + BLOCK_SIZE){
            if(bullet.y + bullet.width > blockY && bullet.y < blockY + BLOCK_SIZE/4){
              bullet.speedY *= -1;
              bullet.y=blockY - bullet.width;
            }
            }//地面
            if(bullet.x- bullet.speedX/2 > blockX && bullet.x - bullet.speedX/2< blockX + BLOCK_SIZE){
              if(bullet.y > blockY && bullet.y - bullet.width < blockY + BLOCK_SIZE){
                bullet.speedY = (blockY + BLOCK_SIZE - bullet.y + bullet.width)*1;
              }
            }//天井
            if(bullet.y + bullet.width*3/4 > blockY && bullet.y - bullet.width*3/4 < blockY + BLOCK_SIZE){
              if(bullet.x + bullet.speedX > blockX && bullet.x < blockX + BLOCK_SIZE/3){
                bullet.speedX *= -1;
                bullet.x=blockX - bullet.width;
              }     
            }//左
            if(bullet.y + bullet.width*3/4> blockY && bullet.y - bullet.width*3/4 < blockY + BLOCK_SIZE){
              if(bullet.x > blockX + BLOCK_SIZE*2/3 && bullet.x + bullet.speedX < blockX + BLOCK_SIZE){
                bullet.speedX *= -1;
                bullet.x=blockX + BLOCK_SIZE + bullet.width;
              }     
            }//右  
          //for calculate process speed
          ps++;
          });
          //Enemy
          enemys.forEach((enemy, enemyIndex) => {
            if(enemy.x + enemy.width/4 > blockX && enemy.x - enemy.width/4< blockX + BLOCK_SIZE){
            if(enemy.y + enemy.width > blockY && enemy.y < blockY + BLOCK_SIZE/4){
              enemy.speedY *= -1;
              enemy.y=blockY - enemy.width;
            }
            }//地面
            if(enemy.x- enemy.speedX/2 > blockX && enemy.x - enemy.speedX/2< blockX + BLOCK_SIZE){
              if(enemy.y > blockY && enemy.y - enemy.width < blockY + BLOCK_SIZE){
                enemy.speedY = (blockY + BLOCK_SIZE - enemy.y + enemy.width)*1;
              }
            }//天井
            if(enemy.y + enemy.width*3/4 > blockY && enemy.y - enemy.width*3/4 < blockY + BLOCK_SIZE){
              if(enemy.x + enemy.speedX > blockX && enemy.x < blockX + BLOCK_SIZE/3){
                enemy.speedX *= -1;
                enemy.x=blockX - enemy.width;
              }     
            }//左
            if(enemy.y + enemy.width*3/4> blockY && enemy.y - enemy.width*3/4 < blockY + BLOCK_SIZE){
              if(enemy.x > blockX + BLOCK_SIZE*2/3 && enemy.x + enemy.speedX < blockX + BLOCK_SIZE){
                enemy.speedX *= -1;
                enemy.x=blockX + BLOCK_SIZE + enemy.width;
              }     
            }//右   
          //for calculate process speed
          ps++;
          });
          //Rocket
          rockets.forEach((rocket, rocketIndex) => {
            if (rocket.x + rkt.radius > blockX && rocket.x - rkt.radius< blockX + BLOCK_SIZE &&
                rocket.y + rkt.radius > blockY && rocket.y - rkt.radius< blockY + BLOCK_SIZE) {
              // ブロックを破壊
              BLOCK_MATRIX[row][col] = 8;
              for (var i = 0; i < 20; i++) {
                enm.x = blockX + BLOCK_SIZE/2 + 10*Math.cos(i*Math.PI/10);
                enm.y = blockY + BLOCK_SIZE/2 + 10*Math.sin(i*Math.PI/10);
                enm.radius = 3
                enm.speedx = 3*Math.cos(i*Math.PI/10);
                enm.speedy = 3*Math.sin(i*Math.PI/10);
                shootEnemy();
                blt.x = blockX + BLOCK_SIZE/2;
                blt.y = blockY + BLOCK_SIZE/2;
                blt.radius = 3
                blt.speedx = 3*Math.cos(i*Math.PI/10 + Math.PI/20);
                blt.speedy = 3*Math.sin(i*Math.PI/10 + Math.PI/20);
                shootBullet();
              }
              breaksound.pause();
              breaksound.currentTime = 0; // 再生位置をリセット
              breaksound.play(); // サウンドを再生
              // 弾を削除
              rockets.splice(rocketIndex, 1);
              drowMap(Matrix);
            }
          //for calculate process speed
          ps++;
          });     
        }
        if (BLOCK_MATRIX[row][col] === 2 && blockX<canvas.width+100 && blockX>-50){
          nplayer.x=blockX;
          nplayer.y=blockY;
          generateNplayer();
          // ブロックを変更
          BLOCK_MATRIX[row][col] = 7;
        }
        if (BLOCK_MATRIX[row][col] === 3 && blockX<canvas.width+150 && blockX>-100){
          if(player1.x > blockX && player1.x < blockX + BLOCK_SIZE && player1.y + player1.radius/2 > blockY && player1.y < blockY + BLOCK_SIZE){
            itemsound.pause();
            itemsound.currentTime = 0; // 再生位置をリセット
            itemsound.play(); // サウンドを再生
            //erase block
            BLOCK_MATRIX[row][col] = 0;
            //map redraw
            drowMap(Matrix);
            if(player1.type === 0){
              player1.type=1; 
              player1.headcolor='darkviolet'; 
              player1.bodycolor='indigo'}
            else if(player1.type === 1){
              player1.type=2; 
              player1.headcolor='silver'; 
              player1.bodycolor='dimgray'}
            else if(player1.type === 2){
              player1.type=0; 
              player1.headcolor='olive'; 
              player1.bodycolor='darkolivegreen'}
            else if(player1.type === -1){
              player1.type=0; 
              player1.headcolor='olive'; 
              player1.bodycolor='darkolivegreen'
              //restatus
              player1.maxhp=100;
              player1.hp=100;
              player1.hpgain=1/30;
              player1.maxmp=100;
              player1.mp=100;
              player1.mpgain=1/2;
              player1.spe=4.5;
            }
            //status
            drawstatus();   
          }    
          //for calculate process speed
          ps++;
        }
        if (BLOCK_MATRIX[row][col] === 4 && blockX<canvas.width+50 && blockX>-50){
          goal.x=blockX; goal.y=blockY;
          if(player1.x > blockX && player1.x < blockX + BLOCK_SIZE && player1.y + player1.radius/2 > blockY && player1.y < blockY + BLOCK_SIZE){
            player1.hp=-100
            goal.n=1;
          }
          //for calculate process speed
          ps++;
        }
        if (BLOCK_MATRIX[row][col] === 5 && blockX<canvas.width+150 && blockX>-100){
          //player1跳ね返り
          if(player1.x + player1.radius/4 > blockX && player1.x - player1.radius/4< blockX + BLOCK_SIZE){
            if(player1.y + player1.radius*3/4 > blockY && player1.y < blockY + BLOCK_SIZE/4){
              if(player1.speedy>0.2){
                ishoversound=0;
                hoversound.pause();
                landsound.pause();
                landsound.currentTime = 0; // 再生位置をリセット
                landsound.play(); // サウンドを再生
              }
              player1.speedy *= 0;
              player1.y=blockY - player1.radius*3/4;
              if(controller['KeyW'] == false){
                player1.jump1=2; 
                player1.jump2=0;
              }
            //for calculate process speed
            ps++;
            }
          }//地面
          if(player1.x + player1.radius/4 > blockX && player1.x - player1.radius/4< blockX + BLOCK_SIZE){
            if(player1.y > blockY && player1.y - player1.radius/4 < blockY + BLOCK_SIZE){
              player1.speedy = (blockY + BLOCK_SIZE - player1.y + player1.radius/4)*1;
            }
          //for calculate process speed
          ps++;
          }//天井
          if(player1.y + player1.radius/2 > blockY && player1.y < blockY + BLOCK_SIZE){
            if(player1.x + player1.radius/2 > blockX && player1.x < blockX + BLOCK_SIZE/3){
              player1.speedx *= -0.8;
              player1.x=blockX - player1.radius/2;
            }     
          //for calculate process speed
          ps++;
          }//左
          if(player1.y + player1.radius/2> blockY && player1.y < blockY + BLOCK_SIZE){
            if(player1.x > blockX + BLOCK_SIZE*2/3 && player1.x - player1.radius/2 < blockX + BLOCK_SIZE){
              player1.speedx *= -0.8;
              player1.x=blockX + BLOCK_SIZE + player1.radius/2;
            }     
          //for calculate process speed
          ps++;}//右       
          //npc跳ね返り
          npcs.forEach((npc, npcIndex) => {
            if(npc.x>-100 && npc.x<canvas.width+100){
              if(npc.x + npc.radius/4 > blockX && npc.x - npc.radius/4< blockX + BLOCK_SIZE){
                if(npc.y + npc.radius*3/4 > blockY && npc.y < blockY + BLOCK_SIZE/4){
                  npc.speedy *= 0;
                  npc.y=blockY - npc.radius*3/4;
                  if(controller['ArrowUp'] == false){
                    npc.jump1=2; 
                    npc.jump2=0;
                  }
                }
              }//地面
              if(npc.x + npc.radius/4 > blockX && npc.x - npc.radius/4< blockX + BLOCK_SIZE){
                if(npc.y > blockY && npc.y - npc.radius/4 < blockY + BLOCK_SIZE){
                  npc.speedy = (blockY + BLOCK_SIZE - npc.y + npc.radius/4)*1;
                }
              }//天井
              if(npc.y + npc.radius/2 > blockY && npc.y < blockY + BLOCK_SIZE){
                if(npc.x + npc.radius/2 > blockX && npc.x < blockX + BLOCK_SIZE/3){
                  npc.speedx *= -0.8;
                  npc.initialx=npc.initialx-1;
                }     
              }//左
              if(npc.y + npc.radius/2> blockY && npc.y < blockY + BLOCK_SIZE){
                if(npc.x > blockX + BLOCK_SIZE*2/3 && npc.x - npc.radius/2 < blockX + BLOCK_SIZE){
                  npc.speedx *= -0.8;
                  npc.initialx=npc.initialx+1;
                }     
            }//右
              //for calculate process speed
              ps++;
            }
          });

          //Bullet
          bullets.forEach((bullet, bulletIndex) => {
            if (bullet.x + bullet.width > blockX && bullet.x - bullet.width< blockX + BLOCK_SIZE &&
                bullet.y + bullet.width > blockY && bullet.y - bullet.width< blockY + BLOCK_SIZE) {
              // 弾を削除
              ctx.globalAlpha = 0.2;
              ctx.fillStyle = 'red'; 
              ctx.fillRect(bullet.x-10, bullet.y-10, 20, 20);
              ctx.globalAlpha = 1;
              bullets.splice(bulletIndex, 1);
            }  
          //for calculate process speed
          ps++;
          });

          //Enemy
          enemys.forEach((enemy, enemyIndex) => {
            if (enemy.x + enemy.width > blockX && enemy.x - enemy.width< blockX + BLOCK_SIZE &&
                enemy.y + enemy.width > blockY && enemy.y - enemy.width< blockY + BLOCK_SIZE) {
              // 弾を削除
              ctx.globalAlpha = 0.2;
              ctx.fillStyle = 'red'; 
              ctx.fillRect(enemy.x-10, enemy.y-10, 20, 20);
              ctx.globalAlpha = 1;
              enemys.splice(enemyIndex, 1);
            } 
          //for calculate process speed
          ps++;
          });
        
          //biim1
          biim1s.forEach((biim1, biim1Index) => {
            if (biim1.x + biim1.width > blockX && biim1.x - biim1.width< blockX + BLOCK_SIZE &&
                biim1.y + biim1.width > blockY && biim1.y - biim1.width< blockY + BLOCK_SIZE) {
              // 弾を削除
              ctx.globalAlpha = 0.2;
              ctx.fillStyle = 'red'; 
              ctx.fillRect(biim1.x-10, biim1.y-10, 20, 20);
              ctx.globalAlpha = 1;
              biim1s.splice(biim1Index, 1);
            }  
          //for calculate process speed
          ps++;
          });

          //biim2
          biim2s.forEach((biim2, biim2Index) => {
            if (biim2.x + biim2.width > blockX && biim2.x - biim2.width< blockX + BLOCK_SIZE &&
                biim2.y + biim2.width > blockY && biim2.y - biim2.width< blockY + BLOCK_SIZE) {
              // 弾を削除
              ctx.globalAlpha = 0.2;
              ctx.fillStyle = 'red'; 
              ctx.fillRect(biim2.x-10, biim2.y-10, 20, 20);
              ctx.globalAlpha = 1;
              biim2s.splice(biim2Index, 1);
            }  
          //for calculate process speed
          ps++;
          });

          //Rocket
          rockets.forEach((rocket, rocketIndex) => {
            if (rocket.x + rkt.radius > blockX && rocket.x - rkt.radius< blockX + BLOCK_SIZE &&
                rocket.y + rkt.radius > blockY && rocket.y - rkt.radius< blockY + BLOCK_SIZE) {
              // 弾を削除
              for (var i = 0; i < 20; i++) {
                enm.x = rocket.x + 10*Math.cos(i*Math.PI/10);
                enm.y = rocket.y + 10*Math.sin(i*Math.PI/10);
                enm.radius = 3
                enm.speedx = 3*Math.cos(i*Math.PI/10);
                enm.speedy = 3*Math.sin(i*Math.PI/10);
                shootEnemy();
                blt.x = rocket.x ;
                blt.y = rocket.y ;
                blt.radius = 3
                blt.speedx = 3*Math.cos(i*Math.PI/10 + Math.PI/20);
                blt.speedy = 3*Math.sin(i*Math.PI/10 + Math.PI/20);
                shootBullet();
              }
              breaksound.pause();
              breaksound.currentTime = 0; // 再生位置をリセット
              breaksound.play(); // サウンドを再生
              rockets.splice(rocketIndex, 1);
            }
          //for calculate process speed
          ps++;
          });     
        }
        if (BLOCK_MATRIX[row][col] === 6 && blockX<canvas.width+100 && blockX>-50){
          if(t_count%300==0){
            nplayer.x=blockX;
            nplayer.y=blockY;
            generateNplayer();
            warpsound.pause();
            warpsound.currentTime = 0; // 再生位置をリセット
            warpsound.play(); // サウンドを再生
          }
          //Rocket
          rockets.forEach((rocket, rocketIndex) => {
            if (rocket.x + rkt.radius > blockX && rocket.x - rkt.radius< blockX + BLOCK_SIZE &&
                rocket.y + rkt.radius > blockY && rocket.y - rkt.radius< blockY + BLOCK_SIZE) {
              // ブロックを破壊
              BLOCK_MATRIX[row][col] = 0;
              for (var i = 0; i < 20; i++) {
                enm.x = blockX + BLOCK_SIZE/2 + 10*Math.cos(i*Math.PI/10);
                enm.y = blockY + BLOCK_SIZE/2 + 10*Math.sin(i*Math.PI/10);
                enm.radius = 3
                enm.speedx = 3*Math.cos(i*Math.PI/10);
                enm.speedy = 3*Math.sin(i*Math.PI/10);
                shootEnemy();
                blt.x = blockX + BLOCK_SIZE/2;
                blt.y = blockY + BLOCK_SIZE/2;
                blt.radius = 3
                blt.speedx = 3*Math.cos(i*Math.PI/10 + Math.PI/20);
                blt.speedy = 3*Math.sin(i*Math.PI/10 + Math.PI/20);
                shootBullet();
              }
              breaksound.pause();
              breaksound.currentTime = 0; // 再生位置をリセット
              breaksound.play(); // サウンドを再生
              // 弾を削除
              rockets.splice(rocketIndex, 1);
              drowMap(Matrix);
            }
          //for calculate process speed
          ps++;
          }); 
          //Bullet
          bullets.forEach((bullet, bulletIndex) => {
            if (bullet.x + bullet.width > blockX && bullet.x - bullet.width< blockX + BLOCK_SIZE &&
                bullet.y + bullet.width > blockY && bullet.y - bullet.width< blockY + BLOCK_SIZE) {
              // 弾を削除
              ctx.globalAlpha = 0.2;
              ctx.fillStyle = 'red'; 
              ctx.fillRect(bullet.x-10, bullet.y-10, 20, 20);
              ctx.globalAlpha = 1;
              bullets.splice(bulletIndex, 1);
            }  
          //for calculate process speed
          ps++;
          });
        }
        if (BLOCK_MATRIX[row][col] === 7 && (blockX>canvas.width+150 || blockX<-100)){
          BLOCK_MATRIX[row][col] = 2;
        }
        if (BLOCK_MATRIX[row][col] === 8 && t_count%60==0){
        if(Math.random()<1/6){
          //regenerate block1
          BLOCK_MATRIX[row][col] = 1;
          //map redraw
          drowMap(Matrix);
        }
      }
      }
    } 
  }
}
function playerCollision(){
  npcs.forEach((npc, npcIndex) => {
    if (
      npc.x>100 && npc.x<canvas.width-100 &&
      player1.x - player1.radius/2< npc.x + npc.radius/2 &&
      player1.x + player1.radius/2 > npc.x - npc.radius/2 &&
      player1.y - player1.radius/4< npc.y + npc.radius*3/4 &&
      player1.y + player1.radius*3/4 > npc.y - npc.radius/4
    ){
      player1.x += npc.speedx;
      npc.x += player1.speedx;
      player1.speedx = (player1.x-npc.x)/16;
      player1.speedy = (player1.y-npc.y)/10;
      npc.speedx = -player1.speedx;
      npc.speedy = -player1.speedy;
      //damage
      if(player1.y + player1.radius*3/4 > npc.y){
        player1.hp -= 4;
      }
      npc.hp -= 4;
      player1.result+=4;
      player1.taken+=4;
      if(player1.type==-1){
        hit2sound.pause();
        hit2sound.currentTime = 0; // 再生位置をリセット
        hit2sound.play(); // サウンドを再生
      }
      else{
        hitsound.pause();
        hitsound.currentTime = 0; // 再生位置をリセット
        hitsound.play(); // サウンドを再生
      }
      //for calculate process speed
      ps++;
    }
  });
}

//player弾当たり判定  
function playerBltEnm(){
  //bullet-npc
  bullets.forEach((bullet, bulletIndex) => {
    npcs.forEach((npc, npcIndex) => {
      if (
        npc.x>-50 && npc.x<canvas.width+50 &&
        bullet.x - bullet.width< npc.x + npc.radius/2 &&
        bullet.x + bullet.width > npc.x - npc.radius/2 &&
        bullet.y - bullet.width< npc.y + npc.radius*3/4 &&
        bullet.y + bullet.width > npc.y - npc.radius/4
      ){
        bullets.splice(bulletIndex, 1);
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = 'orange'; 
        ctx.fillRect(npc.x - npc.radius/2, npc.y - npc.radius/4, npc.radius, npc.radius);
        ctx.globalAlpha = 1;
        npc.speedx -= (bullet.x - npc.x)/120;
        npc.speedy -= (bullet.y - npc.y)/120;
        if(npc.hp>=0){
          npc.hp-=blt.damage;
          player1.result+=blt.damage;
        }
        //for calculate process speed
        ps++;
      }
    });
  });
  //enemy-player1
  enemys.forEach((enemy, enemyIndex) => {
    if (
      enemy.x - enemy.width< player1.x + player1.radius/2 &&
      enemy.x + enemy.width > player1.x - player1.radius/2 &&
      enemy.y - enemy.width< player1.y + player1.radius*3/4 &&
      enemy.y + enemy.width > player1.y - player1.radius/4
    ){
      enemys.splice(enemyIndex, 1);
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = 'orange'; 
      ctx.fillRect(player1.x - player1.radius/2, player1.y - player1.radius/4, player1.radius, player1.radius);
      ctx.globalAlpha = 1;
      player1.speedx -= (enemy.x - player1.x)/120;
      player1.speedy -= (enemy.y - player1.y)/120;
      if(player1.hp>=0){
        player1.hp -= enm.damage;
        player1.taken += enm.damage;
      }
      //for calculate process speed
      ps++;
    }
  });
}
function playerBim(){
  //biim1-npc
  biim1s.forEach((biim1, biim1Index) => {
    npcs.forEach((npc, npcIndex) => {
      if (
        npc.x>-50 && npc.x<canvas.width+50 &&
        biim1.x - biim1.width< npc.x + npc.radius/2 &&
        biim1.x + biim1.width > npc.x - npc.radius/2 &&
        biim1.y - biim1.width< npc.y + npc.radius*3/4 &&
        biim1.y + biim1.width > npc.y - npc.radius/4
      ){
        biim1s.splice(biim1Index, 1);
        ctx.globalAlpha = 0.1;
        ctx.fillStyle = 'orange'; 
        ctx.fillRect(npc.x - npc.radius/2, npc.y - npc.radius/4, npc.radius, npc.radius);
        ctx.globalAlpha = 1;
        npc.speedx -= (biim1.x - npc.x)/1000;
        npc.speedy -= (biim1.y - npc.y)/1000;
        if(npc.hp>=0){
          npc.hp -= bim1.damage;
          player1.result+=bim1.damage;
        }
      //for calculate process speed
      ps++;
      }
    });
  });
  //biim2-player1
  biim2s.forEach((biim2, biim2Index) => {
    if (
      biim2.x - biim2.width< player1.x + player1.radius/2 &&
      biim2.x + biim2.width > player1.x - player1.radius/2 &&
      biim2.y - biim2.width< player1.y + player1.radius*3/4 &&
      biim2.y + biim2.width > player1.y - player1.radius/4
    ){
      biim2s.splice(biim2Index, 1);
      ctx.globalAlpha = 0.1;
      ctx.fillStyle = 'orange'; 
      ctx.fillRect(player1.x - player1.radius/2, player1.y - player1.radius/4, player1.radius, player1.radius);
      ctx.globalAlpha = 1;
      player1.speedx -= (biim2.x - player1.x)/1000;
      player1.speedy -= (biim2.y - player1.y)/1000;
      if(player1.hp>=0){
        player1.hp -= bim2.damage;
        player1.taken += bim2.damage;
      }
    //for calculate process speed
    ps++;
    }
  });
}
function bltBim1_enmBim2(){
  bullets.forEach((bullet, bulletIndex) => {
    biim2s.forEach((biim2, biim2Index) => {
      if (
        bullet.x - bullet.width< biim2.x + biim2.width &&
        bullet.x + bullet.width > biim2.x - biim2.width&&
        bullet.y - bullet.width< biim2.y + biim2.width &&
        bullet.y + bullet.width > biim2.y - biim2.width
      ) { 
        // Remove the bullet and the biim2
        bullets.splice(bulletIndex, 1);
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = 'red'; 
        ctx.fillRect(biim2.x-10, biim2.y-10, 20, 20);
        ctx.globalAlpha = 1;
        biim2s.splice(biim2Index, 1);
      //for calculate process speed
      ps++;
      }
    });
    enemys.forEach((enemy, enemyIndex) => {
      if (
        bullet.x - bullet.width< enemy.x + enemy.width &&
        bullet.x + bullet.width > enemy.x - enemy.width&&
        bullet.y - bullet.width< enemy.y + enemy.width &&
        bullet.y + bullet.width > enemy.y - enemy.width
      ) { 
        // Remove the bullet and the enemy
        bullets.splice(bulletIndex, 1);
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = 'red'; 
        ctx.fillRect(enemy.x-10, enemy.y-10, 20, 20);
        ctx.globalAlpha = 1;
        enemys.splice(enemyIndex, 1);
      //for calculate process speed
      ps++;
      }
    });
  });
  biim1s.forEach((biim1, biim1Index) => {
    biim2s.forEach((biim2, biim2Index) => {
      if (
        biim1.x - biim1.width< biim2.x + biim2.width &&
        biim1.x + biim1.width > biim2.x - biim2.width&&
        biim1.y - biim1.width< biim2.y + biim2.width &&
        biim1.y + biim1.width > biim2.y - biim2.width
      ) { 
        // Remove the biim1 and the biim2
        biim1s.splice(biim1Index, 1);
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = 'red'; 
        ctx.fillRect(biim2.x-10, biim2.y-10, 20, 20);
        ctx.globalAlpha = 1;
        biim2s.splice(biim2Index, 1);
      //for calculate process speed
      ps++;
      }
    });
    enemys.forEach((enemy, enemyIndex) => {
      if (
        biim1.x - biim1.width< enemy.x + enemy.width &&
        biim1.x + biim1.width > enemy.x - enemy.width&&
        biim1.y - biim1.width< enemy.y + enemy.width &&
        biim1.y + biim1.width > enemy.y - enemy.width
      ) { 
        // Remove the biim1 and the enemy
        biim1s.splice(biim1Index, 1);
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = 'red'; 
        ctx.fillRect(enemy.x-10, enemy.y-10, 20, 20);
        ctx.globalAlpha = 1;
        enemys.splice(enemyIndex, 1);
      //for calculate process speed
      ps++;
      }
    });
  });

}
function playerRocket(){
  //rocket-npc
  rockets.forEach((rocket, rocketIndex) => {
    npcs.forEach((npc, npcIndex) => {
      if (
        npc.x>-100 && npc.x<canvas.width+100 &&
        rocket.x - rkt.radius< npc.x + npc.radius/2 &&
        rocket.x + rkt.radius > npc.x - npc.radius/2 &&
        rocket.y - rkt.radius< npc.y + npc.radius*3/4 &&
        rocket.y + rkt.radius > npc.y - npc.radius/4 
      ){
        ctx.globalAlpha = 0.1;
        ctx.fillStyle = 'orange'; 
        ctx.fillRect(npc.x - npc.radius/2, npc.y - npc.radius/4, npc.radius, npc.radius);
        ctx.globalAlpha = 1;
        npc.speedx = 3*rkt.speedx;
        npc.speedy = 3*rkt.speedy;
        if(npc.hp>=0){
          npc.hp -= rkt.damage;
          player1.result+=rkt.damage;
        }
        // 弾を削除
        for (var i = 0; i < 20; i++) {
          enm.x = rocket.x + 10*Math.cos(i*Math.PI/10);
          enm.y = rocket.y + 10*Math.sin(i*Math.PI/10);
          enm.radius = 3
          enm.speedx = 3*Math.cos(i*Math.PI/10);
          enm.speedy = 3*Math.sin(i*Math.PI/10);
          shootEnemy();
          blt.x = rocket.x ;
          blt.y = rocket.y ;
          blt.radius = 3
          blt.speedx = 3*Math.cos(i*Math.PI/10 + Math.PI/20);
          blt.speedy = 3*Math.sin(i*Math.PI/10 + Math.PI/20);
          shootBullet();
        }
        breaksound.pause();
        breaksound.currentTime = 0; // 再生位置をリセット
        breaksound.play(); // サウンドを再生
        //delete rocket
        rockets.splice(rocketIndex, 1);
        //for calculate process speed
        ps++;
      }
    });
  });
  //rocket-player1
  /* 暫定的に出番こない
  rockets.forEach((rocket, rocketIndex) => {  
    if (
      rocket.x - rkt.radius< player1.x + player1.radius/2 &&
      rocket.x + rkt.radius > player1.x - player1.radius/2 &&
      rocket.y - rkt.radius< player1.y + player1.radius*3/4 &&
      rocket.y + rkt.radius > player1.y - player1.radius/4
    ){
      ctx.globalAlpha = 0.1;
      ctx.fillStyle = 'orange'; 
      ctx.fillRect(player1.x - player1.radius/2, player1.y - player1.radius/4, player1.radius, player1.radius);
      ctx.globalAlpha = 1;
      nplayer.result+=1/4;
      player1.x = rocket.x + player1.speedx;
      player1.y = rocket.y + player1.speedy;
      if(player1.hp>=0){
        player1.hp-=1/4;
      }
      var i = Math.random();
      bim1.x = player1.x + 15*Math.cos(2*i*Math.PI);
      bim1.y = player1.y + 15*Math.sin(2*i*Math.PI);
      bim1.radius = 3
      bim1.speedx = 4*Math.cos(2*i*Math.PI);
      bim1.speedy = 4*Math.sin(2*i*Math.PI);
      shootBiim1();
    //for calculate process speed
    ps++;
    }
  });
  */
}
function rocketBltEnmBim(){
  rockets.forEach((rocket, rocketIndex) => {
    //biim
    biim1s.forEach((biim1, biim1Index) => {
      if (
        rocket.x - rkt.radius< biim1.x + biim1.width &&
        rocket.x + rkt.radius > biim1.x - biim1.width&&
        rocket.y - rkt.radius< biim1.y + biim1.width &&
        rocket.y + rkt.radius > biim1.y - biim1.width
      ) { 
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = 'red'; 
        ctx.fillRect(biim1.x-10, biim1.y-10, 20, 20);
        ctx.globalAlpha = 1;
        biim1s.splice(biim1Index, 1);
        rocket.hp -= 1/2;
        if(rocket.hp<0){
          rockets.splice(rocketIndex, 1);
        }
      //for calculate process speed
      ps++;
      }
    });
    biim2s.forEach((biim2, biim2Index) => {
      if (
        rocket.x - rkt.radius< biim2.x + biim2.width &&
        rocket.x + rkt.radius > biim2.x - biim2.width&&
        rocket.y - rkt.radius< biim2.y + biim2.width &&
        rocket.y + rkt.radius > biim2.y - biim2.width
      ) { 
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = 'red'; 
        ctx.fillRect(biim2.x-10, biim2.y-10, 20, 20);
        ctx.globalAlpha = 1;
        biim2s.splice(biim2Index, 1);
        rocket.hp -= 1/2;
        if(rocket.hp<0){
          rockets.splice(rocketIndex, 1);
        }
      //for calculate process speed
      ps++;
      }
    });
    //bullet
    bullets.forEach((bullet, bulletIndex) => {
      if (
        rocket.x - rkt.radius< bullet.x + bullet.width &&
        rocket.x + rkt.radius > bullet.x - bullet.width&&
        rocket.y - rkt.radius< bullet.y + bullet.width &&
        rocket.y + rkt.radius > bullet.y - bullet.width
      ) { 
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = 'red'; 
        ctx.fillRect(bullet.x-10, bullet.y-10, 20, 20);
        ctx.globalAlpha = 1;
        bullets.splice(bulletIndex, 1);
        rocket.hp -= 1;
        if(rocket.hp<0){
          rockets.splice(rocketIndex, 1);
        }
      //for calculate process speed
      ps++;
      }
    });
    //enemy
    enemys.forEach((enemy, enemyIndex) => {
      if (
        rocket.x - rkt.radius< enemy.x + enemy.width &&
        rocket.x + rkt.radius > enemy.x - enemy.width&&
        rocket.y - rkt.radius< enemy.y + enemy.width &&
        rocket.y + rkt.radius > enemy.y - enemy.width
      ) { 
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = 'red'; 
        ctx.fillRect(enemy.x-10, enemy.y-10, 20, 20);
        ctx.globalAlpha = 1;
        enemys.splice(enemyIndex, 1);
        rocket.hp -= 1;
        if(rocket.hp<0){
          rockets.splice(rocketIndex, 1);
        }
      //for calculate process speed
      ps++;
      }
    });
  });
}
function playerItem(){
  items.forEach((item, itemIndex) => {
    //当たり判定
    if(
      item.x < player1.x + player1.radius/2 &&
      item.x + BLOCK_SIZE/2 > player1.x - player1.radius/2 &&
      item.y < player1.y + player1.radius*3/4 &&
      item.y + BLOCK_SIZE/2 > player1.y - player1.radius/4
    ){
      //削除
      items.splice(itemIndex, 1);
      //power up
      if(item.type == 0){
        player1.drone+=1;
        //status
        drawstatus();
      }
      //recover
      if(item.type == 1){
        if(player1.hp>player1.maxhp-50){player1.hp=player1.maxhp}else{player1.hp+=50}
      }
      //plus one cannon
      if(item.type == 2 && player1.state*10<player1.expcap){
        player1.state+=1;
        //status
        drawstatus();
      }
      //sound
      itemsound.pause();
      itemsound.currentTime = 0; // 再生位置をリセット
      itemsound.play(); // サウンドを再生
    }
  });
}
function minenpc(){
  mines.forEach((mine, mineIndex) => {
    npcs.forEach((npc, npcIndex) => {
      if (
        npc.x>-50 && npc.x<canvas.width+50 &&
        mine.x - BLOCK_SIZE/4 < npc.x + npc.radius/2 &&
        mine.x + BLOCK_SIZE/4 > npc.x - npc.radius/2 &&
        mine.y - BLOCK_SIZE/2 < npc.y + npc.radius*3/4 &&
        mine.y > npc.y - npc.radius/4
      ){
        //爆発の破片
        for (var i = 0; i < 20; i++) {
          enm.x = min.x + 10*Math.cos(i*Math.PI/10);
          enm.y = min.y + 10*Math.sin(i*Math.PI/10);
          enm.radius = 3
          enm.speedx = 3*Math.cos(i*Math.PI/10);
          enm.speedy = 3*Math.sin(i*Math.PI/10);
          shootEnemy();
          blt.x = min.x ;
          blt.y = min.y ;
          blt.radius = 3
          blt.speedx = 3*Math.cos(i*Math.PI/10 + Math.PI/20);
          blt.speedy = 3*Math.sin(i*Math.PI/10 + Math.PI/20);
          shootBullet();
        }//削除
        mines.splice(mineIndex, 1);
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = 'red'; 
        ctx.fillRect(npc.x - npc.radius/2, npc.y - npc.radius/4, npc.radius, npc.radius);
        ctx.globalAlpha = 1;
        npc.speedx -= (mine.x - npc.x)/20;
        npc.speedy -= (mine.y - npc.y)/20;
        if(npc.hp>=0){
          npc.hp-=min.damage;
          player1.result+=min.damage;
        }
        //for calculate process speed
        ps++;
      }
    });
  });
}

//controll key
function controll(){
  //for second jump
  if(Math.abs(player1.speedy)>0.1  && controller['KeyW'] == false){
    player1.jump2+=1
  }
 
  //new control system
  if(controller['ShiftLeft']){
    if(player1.type === 0){superbullet()}
    else if(player1.type === 1){biimshot()}
    else if(player1.type === 2){bombrocket()}
    else if(player1.type === -1){gunshot()}
  }
  //KeyF
  if(player1.type === 2){
    if(controller['KeyF'] && player1.mp>0){
      tele1.ed = true;
      tele1.count += 1;
      tele1.x = player1.x + tele1.count*3*Math.cos(player1.angle);
      tele1.y = player1.y + tele1.count*3*Math.sin(player1.angle);
      player1.mp -= 1;
      ctx.fillStyle = player1.headcolor;
      ctx.globalAlpha = 1/4;
      for (var i = 0; i < 20; i++){
        ctx.beginPath();
        ctx.arc((i*player1.x + (20-i)*tele1.x)/20, (i*player1.y + (20-i)*tele1.y)/20, (i/5)**2, 0,Math.PI * 2);
        ctx.fill();
        ctx.closePath();
      }
      ctx.globalAlpha = 1;}
    else if(tele1.ed){
    tele1.ed = false;
    tele1.count = 0;
    //ゲート
    bim2.t = 4;
    for (var j = 0; j < 5; j++){
      for (var i = 0; i < 10; i++) {
        bim2.x = player1.x + 20*Math.cos(i*Math.PI/5);
        bim2.y = player1.y + 20*Math.sin(i*Math.PI/5);
        bim2.radius = 5/(j+1)
        bim2.speedx = -(j+1)*Math.sin(i*Math.PI/5);
        bim2.speedy = (j+1)*Math.cos(i*Math.PI/5);
        shootBiim2();
      }
    }
    mapX += tele1.x-player1.x
    player1.x = tele1.x;
    player1.y = tele1.y;
    warpsound.pause();
    warpsound.currentTime = 0; // 再生位置をリセット
    warpsound.play(); // サウンドを再生
  }
  }
  else if(controller['KeyF']){
    if(player1.type === 0){shield()}
    else if(player1.type === 1){superbiim()}
    else{groundmine();}
  }

  //previous controll keys
  //teleport
  if(controller['Digit2'] && player1.mp>0){
    if(tele1.count>60){
      if(tele1.in == 0){
        //痕跡
        bim1.t = 300;
        bim1.x = player1.x;
        bim1.y = player1.y;
        bim1.speedx = 0;
        bim1.speedy = 0;
        for (var i = 0; i < 10; i++) {
          bim1.radius = i/2+5;
          shootBiim1();
        }
        tele1.x=player1.x;
        tele1.y=player1.y;
        tele1.in=1;
        tele1.count=-60
      }
      else{
        //ゲート
        bim1.t = 4;
        for (var j = 0; j < 5; j++){
          for (var i = 0; i < 10; i++) {
            bim1.x = player1.x + 20*Math.cos(i*Math.PI/5);
            bim1.y = player1.y + 20*Math.sin(i*Math.PI/5);
            bim1.radius = 5/(j+1)
            bim1.speedx = -(j+1)*Math.sin(i*Math.PI/5);
            bim1.speedy = (j+1)*Math.cos(i*Math.PI/5);
            shootBiim1();
          }
        }
        player1.x = tele1.x;
        player1.y = tele1.y;
        tele1.in = 0;
        tele1.count = 0;
      }
    }
    else {
      if(tele1.count%6==0 && tele1.count>0){
        bim1.t = 20;
        for (var i = 0; i < 10; i++) {
          var a = Math.random();
          bim1.x = player1.x + 40*Math.cos((2*a+i/5)*Math.PI);
          bim1.y = player1.y + 40*Math.sin((2*a+i/5)*Math.PI);
          bim1.radius = 5/(i+1)
          bim1.speedx = -(i+1)*Math.cos((2*a+i/5)*Math.PI);
          bim1.speedy = -(i+1)*Math.sin((2*a+i/5)*Math.PI);
          shootBiim1();
        }
        player1.mp-=0.3
      }
      tele1.count+=1;
    }
  }
  
  //move
  if(controller['KeyW'] && player1.mp>8){
    //JUMP
    if(player1.jump1>1){
      if(player1.speedy>1){
        player1.speedy=2;
      }
      player1.y-=1;
      player1.speedy -= (player1.spe+1)/2;
      player1.jump1-=1;
      player1.mp-=10;
      bim1.t = 30
      boostsound.pause();
      boostsound.currentTime = 0; // 再生位置をリセット
      boostsound.play(); // サウンドを再生
      for (var i = 0; i < 50; i++) {
        bim1.x = player1.x;
        bim1.y = player1.y + player1.radius/2;
        bim1.radius = Math.sqrt(50/(i+1))
        bim1.speedx = Math.random()/2-1/4;
        bim1.speedy = (i+1)/3;
        shootBiim1();
      }
    }
    else if(player1.jump2>0 && player1.jump1>0){
      player1.speedy -= (player1.spe+1)/2;
      player1.jump1-=1;
      player1.mp-=5;
      bim1.t = 30
      boostsound.pause();
      boostsound.currentTime = 0; // 再生位置をリセット
      boostsound.play(); // サウンドを再生
      for (var i = 0; i < 50; i++) {
        bim1.x = player1.x;
        bim1.y = player1.y + player1.radius/2;
        bim1.radius = Math.sqrt(50/(i+1))
        bim1.speedx = Math.random()/2-1/4;
        bim1.speedy = (i+1)/3;
        shootBiim1();
      }
    }
    else if(player1.speedy>0){
      player1.speedy -= 0.1*player1.speedy;
      player1.mp-=0.4;
      //噴射
        bim1.x = player1.x;
        bim1.y = player1.y + player1.radius/2;
        bim1.radius = 2
        bim1.speedx = Math.random()/2-1/4;
        bim1.speedy = 5;
        shootBiim1();
      if(ishoversound==0){
        hoversound.pause();
        hoversound.currentTime = 0; // 再生位置をリセット
        hoversound.play(); // サウンドを再生
        ishoversound=1;
      }
    }
  }
  else if(ishoversound==1){
    ishoversound=0;
    hoversound.pause();
  }
  if(controller['KeyS'] && player1.mp>0){
    player1.mp-=1.5;
    player1.y += 1;
    player1.speedy += 1/4;
    bim1.t = 2;
    if(isfiresound==0){
      firesound.pause();
      firesound.currentTime = 0; // 再生位置をリセット
      firesound.play(); // サウンドを再生
      isfiresound=1;
    }
    if(player1.type==0){
      for (var i = 0; i < 20; i++) {
        bim1.x = player1.x + 17*Math.cos(t_count*Math.PI/4);
        bim1.y = player1.y + 9 + 7*Math.sin(t_count*Math.PI/4);
        bim1.radius = Math.sqrt(20/(i+1))
        bim1.speedx = Math.random()-1/2;
        bim1.speedy = -i/2;
        shootBiim1();
      }
    }
    else if(player1.type==1){
      for (var i = 0; i < 20; i++) {
        bim1.x = player1.x + 17*Math.cos(t_count*Math.PI);
        bim1.y = player1.y + 9;
        bim1.radius = Math.sqrt(20/(i+1))
        bim1.speedx = Math.random()-1/2;
        bim1.speedy = -i/2;
        shootBiim1();
      }
    }
    else{
      for (var i = 0; i < 20; i++) {
        bim1.x = player1.x + 15*Math.cos(t_count+i/10);
        bim1.y = player1.y + 15*Math.sin(t_count+i/10);
        bim1.radius = Math.sqrt(36/(i+1))
        bim1.speedx = -(i+10)*Math.sin(t_count+i/10)/10;
        bim1.speedy = (i+10)*Math.cos(t_count+i/10)/10;
        shootBiim1();
      }
    }
  }
  else if(isfiresound==1){
    isfiresound=0;
    firesound.pause();
  }
  if(controller['KeyD'] && player1.mp>0){
    player1.mp-=0.3;
    player1.x += player1.spe/5;
    player1.speedx += player1.spe*0.06;
  }
  if(controller['KeyA'] && player1.mp>0){
    player1.mp-=0.3;
    player1.x -= player1.spe/5;
    player1.speedx -= player1.spe*0.06;
  }
  if(controller['KeyC']){
    player1.angle-=Math.PI/180;
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.25)';
    ctx.moveTo(player1.x, player1.y);
    ctx.lineTo(player1.x+200*Math.cos(player1.angle), player1.y+200*Math.sin(player1.angle));
    ctx.stroke();
    ctx.strokeStyle = 'rgba(0, 0, 0, 1)';
  }
  if(controller['KeyV']){
    player1.angle+=Math.PI/180;
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.25)';
    ctx.moveTo(player1.x, player1.y);
    ctx.lineTo(player1.x+200*Math.cos(player1.angle), player1.y+200*Math.sin(player1.angle));
    ctx.stroke();
    ctx.strokeStyle = 'rgba(0, 0, 0, 1)';
  }
  //照準
  if(controller['KeyB']){
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.25)';
    ctx.moveTo(player1.x, player1.y);
    ctx.lineTo(player1.x+200*Math.cos(player1.angle), player1.y+200*Math.sin(player1.angle));
    ctx.stroke();
    ctx.strokeStyle = 'rgba(0, 0, 0, 1)';
  }
  //強制退去　隠しキー
  if(controller['KeyM']){
    if(player1.mp>50){
      player1.mp-=50;
      bim1.t = 10;
      for (var i = 0; i < 100; i++) {
        bim1.x = player1.x;
        bim1.y = player1.y;
        bim1.radius = 3;
        bim1.speedx = -3*Math.sin(i/50*Math.PI);
        bim1.speedy = 3*Math.cos(i/50*Math.PI);
        shootBiim1();
      }
      npcs.forEach(npc => {
        if(npc.x>0 && npc.x<canvas.width){
          npc.hp=1
            for (var i = 0; i < 30; i++) {
            blt.f = 3;
            blt.x = npc.x;
            blt.y = npc.y;
            blt.radius = 3
            blt.speedx = blt.f*Math.cos(i*Math.PI/15);
            blt.speedy = blt.f*Math.sin(i*Math.PI/15);
            shootBullet();
          }
        }
      })
    }
  }
}

//shot and special moves
function gunshot(){
  if(player1.mp>0){bim1.t = 45
    if(bim1.count>bim1.delay/2){
      shotsound.pause();
      shotsound.currentTime = 0; // 再生位置をリセット
      shotsound.play(); // サウンドを再生
      //弾
      bim1.radius = 2.5;
      for (var i = 0; i < 3; i++) {
        bim1.x = player1.x + 11*Math.cos(player1.angle);
        bim1.y = player1.y + 11*Math.sin(player1.angle);
        bim1.speedx = (i/6+6)*Math.cos(player1.angle);
        bim1.speedy = (i/6+6)*Math.sin(player1.angle);
        shootBiim1();
      }
      bim1.count=0;
      /* 無反動
      player1.speedx -= Math.cos(player1.angle)/6;
      player1.speedy -= Math.sin(player1.angle)/6;
      */
    }
    else{
      player1.mp-=13/bim1.delay;
      bim1.count+=1;
    }
  } 
  if(player1.drone>0){
    if(t_count%Math.ceil(bim1.delay/player1.drone)==0){
      shotsound.pause();
      shotsound.currentTime = 0; // 再生位置をリセット
      shotsound.play(); // サウンドを再生
      //弾
      bim1.x = player1.x - 20*Math.sin(t_count/100+Math.PI*2*t_count/bim1.delay);
      bim1.y = player1.y + 8*Math.cos(t_count/100+Math.PI*2*t_count/bim1.delay);
      bim1.radius = 2.5;
      bim1.speedx = 5*Math.cos(player1.angle);
      bim1.speedy = 5*Math.sin(player1.angle);
      for (var i = 0; i < 3; i++) {
        shootBiim1();
      }
    }
  }
}
function superbullet(){
  if(player1.mp>0){
    if(blt.count>blt.delay && player1.mp>=20){
      audio_buffer_node.start(0); // オーディオを再生
      prepareAudioBufferNode(); // 次回の再生のために準備を行う
      //弾
      blt.f = 8;
      blt.x = player1.x + (20)*Math.cos(player1.angle);
      blt.y = player1.y + (20)*Math.sin(player1.angle);
      blt.radius = 5;
      blt.speedx = blt.f*Math.cos(player1.angle);
      blt.speedy = blt.f*Math.sin(player1.angle);
      for (var i = 0; i < 20; i++){
      shootBullet();}
      player1.speedx -= Math.cos(player1.angle)/4;
      player1.speedy -= Math.sin(player1.angle)/4;
      blt.count=0;
      player1.mp-=20;
    }
  }
  if(player1.drone>0){
    if(t_count%Math.ceil(blt.delay*4/player1.drone)==0){
      cannonsound.pause();
      cannonsound.currentTime = 0; // 再生位置をリセット
      cannonsound.play(); // サウンドを再生
      //弾
      blt.f = 6;
      blt.x = player1.x - (20)*Math.sin(t_count/100+Math.PI*2*t_count/bim1.delay);
      blt.y = player1.y + (8)*Math.cos(t_count/100+Math.PI*2*t_count/bim1.delay);
      blt.radius = 5;
      blt.speedx = blt.f*Math.cos(player1.angle);
      blt.speedy = blt.f*Math.sin(player1.angle);
      for (var i = 0; i < 10; i++){
      shootBullet();}
    }
  }
}
function shield(){
  if(player1.mp>0){
    if(blt.count>60 && player1.mp>50){
      bombsound.pause();
      bombsound.currentTime = 0; // 再生位置をリセット
      bombsound.play(); // サウンドを再生
      for (var i = 0; i < 60; i++) {
        blt.f = 4;
        blt.x = player1.x;
        blt.y = player1.y;
        blt.radius = 3
        blt.speedx = blt.f*Math.cos(i*Math.PI/30);
        blt.speedy = blt.f*Math.sin(i*Math.PI/30);
        shootBullet();
      }
      player1.speedy -= 1;
      blt.count=0; 
      player1.mp-=50; 
      //斥力
      npcs.forEach((npc, npcIndex) => {
        dx= npc.x-player1.x
        dy= npc.y-player1.y
        d2=dx**2+dy**2
        npc.speedx = 1000*dx/d2;
        npc.speedy = 500*dy/d2;
        //damage
        damage=30000/d2;
        npc.hp-=damage;
        player1.result+=damage;
        //for calculate process speed
        ps++;
      });
    }
  }
}
function superbiim(){
  if(player1.mp>0){
  bim1.t = 150
  if(player1.mp>1){
    if(bim1.count>90){
      for (var i = 0; i < 500; i++) {
        bim1.x = player1.x + 25*Math.cos(player1.angle);
        bim1.y = player1.y + 25*Math.sin(player1.angle);
        bim1.radius = (512/(i+1))**(1/3)
        bim1.speedx = (i+5)*Math.cos(player1.angle)/30;
        bim1.speedy = (i+5)*Math.sin(player1.angle)/30;
        shootBiim1();
      }
      bim1.count=0;
      player1.speedx -= Math.cos(player1.angle);
      player1.speedy -= Math.sin(player1.angle);
      biimsound.pause();
      biimsound.currentTime = 0; // 再生位置をリセット
      biimsound.play(); // サウンドを再生
    }
    else{
      player1.mp-=1;
      bim1.count+=1;
      ctx.beginPath();
      ctx.fillStyle = player1.headcolor;
      ctx.globalAlpha = bim1.count/90;
      ctx.arc(player1.x + 25*Math.cos(player1.angle), player1.y + 25*Math.sin(player1.angle), Math.sqrt(bim1.count/2), 0,Math.PI * 2);
      ctx.fill();
      ctx.closePath();
      ctx.globalAlpha = 1;
    }
  }}
}
function biimshot(){
  if(player1.mp>0){bim1.t = 150
    if(bim1.count>bim1.delay){
      shotsound.pause();
      shotsound.currentTime = 0; // 再生位置をリセット
      shotsound.play(); // サウンドを再生
      for (var i = 0; i < 20; i++) {
        bim1.x = player1.x + 25*Math.cos(player1.angle);
        bim1.y = player1.y + 25*Math.sin(player1.angle);
        bim1.radius = i/5+1
        bim1.speedx = (i/20+4)*Math.cos(player1.angle);
        bim1.speedy = (i/20+4)*Math.sin(player1.angle);
        shootBiim1();
      }
      bim1.count-=bim1.delay;
      /* 無反動
      player1.speedx -= Math.cos(player1.angle)/6;
      player1.speedy -= Math.sin(player1.angle)/6;
      */
    }
    else{
      player1.mp-=20/bim1.delay;
      bim1.count+=1;
      ctx.beginPath();
      ctx.fillStyle = player1.headcolor;
      ctx.globalAlpha = bim1.count/bim1.delay*0.6;
      ctx.arc(player1.x + 25*Math.cos(player1.angle), player1.y + 25*Math.sin(player1.angle), bim1.count/bim1.delay*5, 0,Math.PI * 2);
      ctx.fill();
      ctx.closePath();
      ctx.globalAlpha = 1;
    }
  } 
  if(player1.drone>0){
    if(t_count%Math.ceil(bim1.delay*4/player1.drone)==0){
      shotsound.pause();
      shotsound.currentTime = 0; // 再生位置をリセット
      shotsound.play(); // サウンドを再生
      //弾
      bim1.x = player1.x - (20)*Math.sin(t_count/100+Math.PI*2*t_count/bim1.delay);
      bim1.y = player1.y + (8)*Math.cos(t_count/100+Math.PI*2*t_count/bim1.delay);
      bim1.radius = 4;
      bim1.speedx = 4*Math.cos(player1.angle);
      bim1.speedy = 4*Math.sin(player1.angle);
      for (var i = 0; i < 10; i++) {
        shootBiim1();
      }
    }
  }
}
function bombrocket(){
  if(player1.mp>0){
    if(rkt.count1>rkt.delay){
      rocketsound.pause();
      rocketsound.currentTime = 0; // 再生位置をリセット
      rocketsound.play(); // サウンドを再生
      rkt.angle = player1.angle;
      rkt.x = player1.x + 25*Math.cos(player1.angle);
      rkt.y = player1.y + 25*Math.sin(player1.angle);
      rkt.radius = 5
      rkt.speedx = 4*Math.cos(player1.angle);
      rkt.speedy = 4*Math.sin(player1.angle);
      shootRocket();  
      rkt.count1 = 0;
      player1.speedx -= Math.cos(player1.angle);
      player1.speedy -= Math.sin(player1.angle);
    }
    else{
      player1.mp-=50/rkt.delay;
      rkt.count1+=1;
      ctx.beginPath();
      ctx.fillStyle = 'black';
      ctx.globalAlpha = rkt.count1/rkt.delay/3;
      ctx.arc(player1.x + 25*Math.cos(player1.angle), player1.y + 25*Math.sin(player1.angle), 5, 0,Math.PI * 2);
      ctx.arc(player1.x + 20*Math.cos(player1.angle), player1.y + 20*Math.sin(player1.angle), 5, 0,Math.PI * 2);
      ctx.fill();
      ctx.closePath();
    }
  }
  if(player1.drone>0){
    if(t_count%Math.ceil(rkt.delay*4/player1.drone)==0){
      rocketsound.pause();
      rocketsound.currentTime = 0; // 再生位置をリセット
      rocketsound.play(); // サウンドを再生
      //弾
      rkt.angle = player1.angle;
      rkt.x = player1.x - (20)*Math.sin(t_count/100+Math.PI*2*t_count/bim1.delay);
      rkt.y = player1.y + (8)*Math.cos(t_count/100+Math.PI*2*t_count/bim1.delay);
      rkt.radius = 5;
      rkt.speedx = 3*Math.cos(player1.angle);
      rkt.speedy = 3*Math.sin(player1.angle);
      shootRocket();
    }
  }
}
function groundmine(){
  if(player1.mp>0){
    if(min.count>min.delay){
      landsound.pause();
      landsound.currentTime = 0; // 再生位置をリセット
      landsound.play(); // サウンドを再生
      min.x = player1.x;
      min.y = player1.y + player1.radius*3/4
      shootMine();
      min.count = 0;
    }
    else{
      player1.mp-=80/min.delay;
      min.count += 1;
      ctx.beginPath();
      ctx.fillStyle = 'black';
      ctx.globalAlpha = min.count/min.delay/3+1/3;
      ctx.arc(player1.x, player1.y + player1.radius*3/4, 5, Math.PI, 0);
      ctx.fill();
      ctx.closePath();
    }
  }

}

//Text
function Text(text,t){
  if(t_count>t*60 && t_count<(t+1.5)*60){
    ctx.globalAlpha = 0.4;
    ctx.fillStyle = 'white';
    ctx.font = '24px Arial';
    ctx.fillText(text, canvas.width/2-100, canvas.height/2);
  }
}

//menu and psuse
function menu(){
  menuctx.fillStyle = '#ECB8B8'; //236, 184, 184
  menuctx.globalAlpha = 0.3;
  menuctx.fillRect(100,100,400,390);
  //for calculate process speed
  ps++;
}
function drawstatus(){
  menuctx.clearRect(0, 490, menuCanvas.width, menuCanvas.height-490);
  //描画psuse
  menuctx.fillStyle = '#ECB8B8'; //236, 184, 184
  menuctx.globalAlpha = 1;
  menuctx.fillRect(520,500,80,30);
  menuctx.font = '20px Arial';
  menuctx.fillStyle = '#251743'; 
  //for status frames
  menuctx.fillRect(90,502,100,6);
  menuctx.fillRect(90,527,100,6);
  menuctx.fillRect(90,552,100,6);
  menuctx.fillRect(90,577,100,6);
  menuctx.fillRect(280,502,100,6);
  menuctx.fillRect(280,527,100,6);
  menuctx.fillRect(280,552,100,6);
  menuctx.fillRect(304,576,77,8);
  //pause frame
  menuctx.fillRect(521,501,78,28);
  menuctx.fillStyle = '#ECB8B8'; //236, 184, 184
  menuctx.fillText("PAUSE", 528, 522);
  //描画status
  menuctx.font = '12px Arial';
  if(player1.state*10<player1.expcap/10 || player1.grade<=player1.grade1){menuctx.fillStyle='#966464';} //not enough exp
  menuctx.fillText("maxHP", 10, 510);
  if(player1.state*10<player1.expcap/10 || player1.grade<=player1.grade2){menuctx.fillStyle='#966464';} //not enough exp
  else{menuctx.fillStyle = '#ECB8B8';}
  menuctx.fillText(" HP +", 10, 535);
  if(player1.state*10<player1.expcap/10 || player1.grade<=player1.grade3){menuctx.fillStyle='#966464';} //not enough exp
  else{menuctx.fillStyle = '#ECB8B8';}
  menuctx.fillText("maxEP", 10, 560);
  if(player1.state*10<player1.expcap/10 || player1.grade<=player1.grade4){menuctx.fillStyle='#966464';} //not enough exp
  else{menuctx.fillStyle = '#ECB8B8';}
  menuctx.fillText(" EP +", 10, 585);
  if(player1.state*10<player1.expcap/10 || player1.grade<=player1.grade5){menuctx.fillStyle='#966464';} //not enough exp
  else{menuctx.fillStyle = '#ECB8B8';}
  menuctx.fillText(" ATK", 200, 510);
  if(player1.state*10<player1.expcap/10 || player1.grade<=player1.grade6){menuctx.fillStyle='#966464';} //not enough exp
  else{menuctx.fillStyle = '#ECB8B8';}
  menuctx.fillText("A-Spe", 200, 535);
  if(player1.state*10<player1.expcap/10 || player1.grade<=player1.grade7){menuctx.fillStyle='#966464';} //not enough exp
  else{menuctx.fillStyle = '#ECB8B8';}
  menuctx.fillText("Speed", 200, 560);
  if(player1.state*10<player1.expcap){menuctx.fillStyle='#966464';} //not enough exp
  menuctx.fillText(" EXP", 200, 585);
  //status bar and figure
  menuctx.fillStyle = 'green';
  menuctx.fillText(Math.ceil(player1.maxhp), 60, 510);
  menuctx.fillText(Math.ceil(player1.hpgain*600)/10, 60, 535);
  menuctx.fillRect(90,502,player1.maxhp/4,6);
  menuctx.fillRect(90,527,player1.hpgain*500,6);
  menuctx.fillStyle = 'blue';
  menuctx.fillText(Math.ceil(player1.maxmp), 60, 560);
  menuctx.fillText(Math.ceil(player1.mpgain*600)/10, 60, 585);
  menuctx.fillRect(90,552,player1.maxmp/4,6);
  menuctx.fillRect(90,577,player1.mpgain*200/3,6);
  menuctx.fillStyle = 'red';
  if(player1.type==0){
    menuctx.fillText(Math.ceil(blt.damage*20), 250, 510);
    menuctx.fillText(Math.ceil(600/blt.delay)/10, 250, 535);
    menuctx.fillRect(280,502,blt.damage*20,6);
    menuctx.fillRect(280,527,500/blt.delay,6);
  }
  else if(player1.type==1){
    menuctx.fillText(Math.ceil(bim1.damage*20), 250, 510);
    menuctx.fillText(Math.ceil(600/bim1.delay)/10, 250, 535);
    menuctx.fillRect(280,502,bim1.damage*20,6);
    menuctx.fillRect(280,527,500/bim1.delay,6);
  }
  else if(player1.type==2){
    menuctx.fillText(Math.ceil(rkt.damage), 250, 510);
    menuctx.fillText(Math.ceil(600/rkt.delay)/10, 250, 535);
    menuctx.fillRect(280,502,rkt.damage,6);
    menuctx.fillRect(280,527,500/rkt.delay,6);
  }
  else if(player1.type==-1){
    menuctx.fillText(Math.ceil(bim1.damage*3), 250, 510);
    menuctx.fillText(Math.ceil(120/bim1.delay), 250, 535);
    menuctx.fillRect(280,502,bim1.damage*3,6);
    menuctx.fillRect(280,527,1000/bim1.delay,6);
  }
  menuctx.fillStyle = 'orange';
  menuctx.fillText(Math.ceil(player1.spe*60), 250, 560);
  menuctx.fillRect(280,552,player1.spe*10,6);
  menuctx.fillStyle = 'yellow';
  menuctx.fillText(player1.state*10+" / "+player1.expcap, 250, 585);
  menuctx.fillRect(305,577,player1.state*750/player1.expcap,6);
  //write abilities
  menuctx.fillStyle = '#ECB8B8';
  menuctx.fillText("hold [shift] ↓", 400, 510);
  menuctx.fillText("hold [f] key↓", 400, 560);
  if(player1.type==0){
    menuctx.fillText("Cannon", 400, 530);
    menuctx.fillText("Detonation", 400, 580);
  }
  else if(player1.type==1){
    menuctx.fillText("Beam-Shot", 400, 530);
    menuctx.fillText("Super-Beam", 400, 580);
  }
  else if(player1.type==2){
    menuctx.fillText("Rocket-Bomb", 400, 530);
    menuctx.fillText("Teleport", 400, 580);
  }
  else {
    menuctx.fillText("Beam-Gun", 400, 530);
    menuctx.fillText("Landmine", 400, 580);
  }
  //for calculate process speed
  ps++;
}

//start
function start(){
  //initial background
  const image = new Image();
  image.onload = function() {
    backctx.drawImage(image, 0, 0, canvas.width, canvas.height);
  };
  image.src = 'picture/city.png';
  ctx.fillStyle = '#ECB8B8'; //236, 184, 184
  ctx.font = '20px Arial';
    ctx.fillText("A nuclear bomb coming in "+limit+" sec", 150, 100);
    ctx.fillText("Escape through the enemies", 150, 150);
    ctx.fillText("Go to the warp gate to survive", 150, 200);
    ctx.fillText("[Space]→ no tank: extremely hard", 150, 485);
  ctx.font = '40px Arial';
    ctx.fillText("Push [1] [2] [3] Key to choose", 50, 270);
    ctx.fillText("the Type of your Tank", 100, 315);
  ctx.lineWidth = 2; // 枠線の幅
  ctx.strokeStyle = 'black';
  //draw sample tanks and human
    player1.x=475;
    player1.y=475;
    player1.type=-1;
    player1.headcolor='silver'; 
    player1.bodycolor='dimgray';
  drawPlayers();
  player1.y=360;
  player1.type=0;
    player1.x=400;
  drawPlayers();
    player1.x=300;
    player1.headcolor='darkviolet'; 
    player1.bodycolor='indigo'
  drawPlayers();
    player1.x=200;
    player1.headcolor='olive'; 
    player1.bodycolor='darkolivegreen'
  drawPlayers();
  //menu欄
  drawstatus();
  //goal位置の指定
  for (let row = 0; row < Matrix.length; row++) {
    const rowLength = Matrix[row].length;
    for (let col = 0; col < rowLength; col++) {
      const blockX = col * (BLOCK_SIZE + BLOCK_GAP) - mapX;
      const blockY = row * (BLOCK_SIZE + BLOCK_GAP);
      if (Matrix[row][col] === 4 && blockX<canvas.width+150 && blockX>-100){
        goal.x=blockX; goal.y=blockY;
      }
    } 
  }
  //for test play
  itm.y=400;
  itm.type=2;
  for (var i = 0; i < 4; i++){
    itm.x=220+25*i;
    generateItem();
  }
}
//for game start and restart
function handleKeyPress(event) {
  if (player1.hp<1 && event.code === "Space" && !isFunctionExecuted){
    location.reload();
  }
  if (event.code === "Space" && isFunctionExecuted){
    isFunctionExecuted = false; // フラグをtrue→二度実行されない
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    backctx.clearRect(0, 0, canvas.width, canvas.height);
    //player1のタイプ
    player1.type=-1;
    player1.headcolor='silver'; 
    player1.bodycolor='dimgray';
    player1.maxhp=20;
    player1.hp=20;
    player1.hpgain=1/30;
    player1.maxmp=80;
    player1.mp=80;
    player1.mpgain=1/3;
    player1.spe=4.3;
    drawstatus();
    //sound
    audio_buffer_node.start(0); // オーディオを再生
    prepareAudioBufferNode(); // 次回の再生のために準備を行う 
    //main
    drowMap(Matrix);
    drawstatus();
    gameLoop();
    //for test play
    itm.y=400;
    itm.type=0;
    for (var i = 0; i < 1; i++){
      itm.x=420+25*i;
      generateItem();
    }
    itm.type=2;
    for (var i = 0; i < 4; i++){
      itm.x=320+25*i;
      generateItem();
    }
  }
  if (event.code === "Digit1" && isFunctionExecuted) {
    isFunctionExecuted = false; // フラグをtrue→二度実行されない
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    backctx.clearRect(0, 0, canvas.width, canvas.height);
    //player1のタイプ
    player1.type=0; 
    player1.headcolor='olive'; 
    player1.bodycolor='darkolivegreen'
    //sound
    audio_buffer_node.start(0); // オーディオを再生
    prepareAudioBufferNode(); // 次回の再生のために準備を行う 
    //main
    drowMap(Matrix);
    drawstatus();
    gameLoop();
  }
  else if (event.code === "Digit2" && isFunctionExecuted) {
    isFunctionExecuted = false; // フラグをtrue→二度実行されない
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    backctx.clearRect(0, 0, canvas.width, canvas.height);
    //player1のタイプ
    player1.type=1; 
    player1.headcolor='darkviolet'; 
    player1.bodycolor='indigo'
    //sound
    audio_buffer_node.start(0); // オーディオを再生
    prepareAudioBufferNode(); // 次回の再生のために準備を行う 
    //main
    drowMap(Matrix);
    drawstatus();
    gameLoop();
  }
  else if (event.code === "Digit3" && isFunctionExecuted) {
    isFunctionExecuted = false; // フラグをtrue→二度実行されない
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    backctx.clearRect(0, 0, canvas.width, canvas.height);
    //player1のタイプ
    player1.type=2; 
    player1.headcolor='silver'; 
    player1.bodycolor='dimgray'
    //sound
    audio_buffer_node.start(0); // オーディオを再生
    prepareAudioBufferNode(); // 次回の再生のために準備を行う 
    //main
    drowMap(Matrix);
    drawstatus();
    gameLoop();
  }
}

//post-processing
function finish(){
    player1.result = Math.round(player1.result * 10) / 10
    backctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'white';
    ctx.font = '24px Arial';
    ctx.fillText('Total Damege', 50, 110);
    ctx.fillText('Damege Taken', 50, 170);
    ctx.fillText('enemies defeated', 50, 230);
    ctx.fillText(':', 250, 110);
    ctx.fillText(':', 250, 170);
    ctx.fillText(':', 250, 230);
    ctx.fillText('Push [Space] to Restart', 10, canvas.height-40);
    ctx.font = '50px Arial';
    ctx.globalAlpha = 1;
    ctx.fillText('Failed to survive...', 100, 300);
    ctx.fillText(player1.result, 300, 110);
    ctx.fillText(player1.taken, 300, 170);
    ctx.fillText(player1.kill, 300, 230);
}
function goalin(){
  player1.result = Math.round(player1.result * 10) / 10
  backctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = 'white';
  ctx.font = '24px Arial';
  ctx.fillText('Total Damege', 50, 110);
  ctx.fillText('Damege Taken', 50, 170);
  ctx.fillText('enemies defeated', 50, 230);
  ctx.fillText(':', 250, 110);
  ctx.fillText(':', 250, 170);
  ctx.fillText(':', 250, 230);
  ctx.fillText('Push [Space] to Restart', 10, canvas.height-40);
  ctx.font = '50px Arial';
  ctx.fillStyle = 'gold';
  ctx.globalAlpha = 1;
  ctx.fillText('You survived!', 150, 300);
  ctx.fillText('↓Next stage↓', 150, 370);
  ctx.fillText(player1.result, 300, 110);
  ctx.fillText(player1.taken, 300, 170);
  ctx.fillText(player1.kill, 300, 230);
  button2.style.display = "inline-block";
  //clickbutton button
  button2.onclick = function() {
    window.location.href = 'stage'+(stage+1)+'.html';
  };
}

//==================================
//main
function gameLoop() {
  //reset
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  //操作
  controll();

  //描画、動作
  drawPlayers();
  drawNplayer();
  if(bullets.length>0){
    drawBullet();
  }
  if(enemys.length>0){
    drawEnemy();
  }
  if(biim1s.length>0 || biim2s.length>0){
    drawBiim();
  }
  if(rockets.length>0){  
    drawRocket();
  }
  if(goal.x<canvas.width+50 && goal.x>-50){
    drawgoal()}
  if(items.length>0){
    drawItem()}
  if(mines.length>0){
    drawMine()}

  //ギミック
  Rain(limit/2);
  canon(limit-30);

  //text
  Text('Push [w][a][s][d] to move',0)
  Text('Push Shift on the left',1.5)
  Text('Push Shift on the left',3)
  Text('Push [f] This is special move',4.5)
  Text('Push [f] This is special move',6)

  //ブロック跳ね返り
  blockCollision(Matrix);
  playerCollision();

  //当たり判定
  //player
  playerBltEnm(); 
  playerBim();
  if(rockets.length>0){playerRocket();}
  //弾
  bltBim1_enmBim2();
  if(rockets.length>0){rocketBltEnmBim();}
  //item
  if(items.length>0){playerItem();}
  //mine
  if(mines.length>0){minenpc();}

  //時間経過で消滅
  bullets.forEach((bullet, bulletIndex) => {
    if(bullet.hp>150){
        bullets.splice(bulletIndex, 1);
    }
  });
  enemys.forEach((enemy, enemyIndex) => {
    if(enemy.hp>150){
        enemys.splice(enemyIndex, 1);
    }
  });
  biim1s.forEach((biim1, biim1Index) => {
    biim1.hp+=1
    if(biim1.hp>bim1.t){
      biim1s.splice(biim1Index, 1);
    }
  });
  biim2s.forEach((biim2, biim2Index) => {
    biim2.hp+=1
    if(biim2.hp>bim2.t){
      biim2s.splice(biim2Index, 1);
    }
  });

  //npc消滅
  npcs.forEach((npc, npcIndex) => {
    if(npc.hp<1){
      npcs.splice(npcIndex, 1);
      player1.kill += 1;
      //爆発
      player1.kill += 1;
      blt.x = npc.x;
      blt.y = npc.y;
      blt.radius = 3;
      for (var i = 0; i < 20; i++) {
        blt.speedx = 3*Math.cos(i*Math.PI/10);
        blt.speedy = 3*Math.sin(i*Math.PI/10);
        shootBullet();
      }
      bombsound.pause();
      bombsound.currentTime = 0; // 再生位置をリセット
      bombsound.play(); // サウンドを再生
      //itemを確率で残す
      if(Math.random()<0.05){
        itm.type = 0;
        itm.x = npc.x-5;
        itm.y = npc.y-5;
        generateItem();
      }
      else if(Math.random()<0.1){
        itm.type = 1;
        itm.x = npc.x-5;
        itm.y = npc.y-5;
        generateItem();
      }
      else{
        itm.type = 2;
        itm.x = npc.x-5;
        itm.y = npc.y-5;
        generateItem();
      }
    }
  });

  //count
  t_count+=1;
  blt.count+=1;
  enm.count+=1;

  //hp and mp
  if(player1.hp<player1.maxhp){
    player1.hp+=player1.hpgain;
  }
  if(player1.mp<player1.maxmp){
    player1.mp+=player1.mpgain;
  }
 
  //finish
  if(player1.y>canvas.height+player1.radius){
    player1.hp-=1;
  }
  if(t_count>limit*60){
    player1.hp-=0.3;
    ctx.fillStyle = 'red';
    ctx.globalAlpha = (t_count-limit*60)/1000;
    ctx.fillRect(0,0,canvas.width, canvas.height);
  }
  if(player1.hp<1){
    if(goal.n==0){
      finish();}
    else{
      goalin()
    }
    return;
  }
  else if(ispause==0){
    requestAnimationFrame(gameLoop);
  }

  //time count
  ctx.globalAlpha = 1;
  ctx.fillStyle = 'black';
  ctx.font = '15px Arial';
  ctx.fillText("TIME LIMIT ;", 300, 24);
  if(t_count>limit*60){
    ctx.fillStyle = 'red';
  }
  else if(t_count>(limit-10)*60){
    ctx.fillStyle = 'purple';
  }
  ctx.fillText(limit-Math.round(t_count/60), 400, 24);
  
  //for calculate process speed
  if(t_count%60 == 0){
    ps_true = ps;
    ps = 0;
  }
  ctx.fillStyle = 'gray';
  ctx.font = '10px Arial';
  ctx.fillText(ps_true, 10, 24);
}


// 実行
start()
//controller
document.addEventListener('keydown', (event) => {
    controller[event.code] = true;
});
document.addEventListener('keyup', (event) => {
    controller[event.code] = false;
});
menuCanvas.addEventListener("mousemove", function(event) {
  const rect = menuCanvas.getBoundingClientRect();
  const mouse_x = event.clientX - rect.left;
  const mouse_y = event.clientY - rect.top;
  if(player1.x>mouse_x){
    player1.angle = Math.PI+Math.atan((player1.y-mouse_y)/(player1.x-mouse_x));
  }
  else{
    player1.angle = Math.atan((player1.y-mouse_y)/(player1.x-mouse_x));
  }
  //pause
  if(mouse_y>490){
    drawstatus();
    if(ispause==0 && mouse_x>520 && mouse_x<600 && mouse_y<530 && mouse_y>500){
        menuctx.font = '20px Arial';
        menuctx.fillStyle = '#966464';
        menuctx.fillText("PAUSE", 528, 522);
    }
    if(mouse_y>503 && mouse_x>12 && mouse_x<233 && mouse_y<588 && player1.state*10>=player1.expcap/10){
      menuctx.fillStyle='#966464';
      menuctx.font = '12px Arial';
      if(mouse_x<48){
        if(mouse_y<512 && player1.grade>player1.grade1){
          menuctx.fillText("maxHP", 10, 510);
          menuctx.fillText("←raise (-10%EXP)", mouse_x, mouse_y);
        }
        if(mouse_y>528 && mouse_y<537 && player1.grade>player1.grade2){
          menuctx.fillText(" HP +", 10, 535);
          menuctx.fillText("←raise (-10%EXP)", mouse_x, mouse_y);
        }
        if(mouse_y>553 && mouse_y<563 && player1.grade>player1.grade3){
          menuctx.fillText("maxEP", 10, 560);
          menuctx.fillText("←raise (-10%EXP)", mouse_x, mouse_y);
        }
        if(mouse_y>578 && player1.grade>player1.grade4){
          menuctx.fillText(" EP +", 10, 585);
          menuctx.fillText("←raise (-10%EXP)", mouse_x, mouse_y);
        }
      }
      else if(mouse_x>202){
        if(mouse_y<512 && player1.grade>player1.grade5){
          menuctx.fillText(" ATK", 200, 510);
          menuctx.fillText("←raise (-10%EXP)", mouse_x, mouse_y);
        }
        if(mouse_y>528 && mouse_y<537 && player1.grade>player1.grade6){
          menuctx.fillText("A-Spe", 200, 535);
          menuctx.fillText("←raise (-10%EXP)", mouse_x, mouse_y);
        }
        if(mouse_y>553 && mouse_y<563 && player1.grade>player1.grade7){
          menuctx.fillText("Speed", 200, 560);
          menuctx.fillText("←raise (-10%EXP)", mouse_x, mouse_y);
        }
        if(mouse_y>578 && player1.state*10>=player1.expcap){
          menuctx.fillText(" EXP", 200, 585);
          menuctx.fillText("UP-GRADE", mouse_x, mouse_y);
        }
      }
    }
  }
});
//pauseをクリックしてメニュウが表示される
menuCanvas.addEventListener("click", function(event) {
  const rect = menuCanvas.getBoundingClientRect();
  const mouse_x = event.clientX - rect.left;
  const mouse_y = event.clientY - rect.top;
  //click outside menu to continue
  if(ispause==1 && mouse_y<490 && (mouse_x<100 || mouse_x>500 || mouse_y<100)){
    ispause=0;
    menuctx.clearRect(0, 0, menuCanvas.width, 500);
    gameLoop();
  }
  //click botton to open menu
  if(mouse_x>520 && mouse_x<600 && mouse_y<530 && mouse_y>500){
    drawstatus();
    ispause=1;
    menuctx.clearRect(0, 0, menuCanvas.width, 500);
    menu();
  }
  //upgrade powerup
  else if(mouse_y>503 && mouse_x>12 && mouse_x<233 && mouse_y<588 && player1.state*10>=player1.expcap/10){
    if(mouse_x<48){
      if(mouse_y<512 && player1.grade>player1.grade1){//hp
        player1.maxhp *= 1.1;
        player1.state -= player1.expcap/100;
        player1.grade1 += 1;
        drawstatus();
      }
      else if(mouse_y>528 && mouse_y<537 && player1.grade>player1.grade2){//hp+
        player1.hpgain *= 1.1
        player1.state -= player1.expcap/100;
        player1.grade2 += 1;
        drawstatus();
      }
      else if(mouse_y>553 && mouse_y<563 && player1.grade>player1.grade3){//mp
        player1.maxmp *= 1.1
        player1.state -= player1.expcap/100;
        player1.grade3 += 1;
        drawstatus();
      }
      else if(mouse_y>578 && player1.grade>player1.grade4){//mp+
        player1.mpgain *= 1.1
        player1.state -= player1.expcap/100;
        player1.grade4 += 1;
        drawstatus();
      }
    }
    else if(mouse_x>202){
      if(mouse_y<512 && player1.grade>player1.grade5){//atk
        if(player1.type==0){
          blt.damage *= 1.1;
        }
        else if(player1.type==1){
          bim1.damage *= 1.1;
        }
        else if(player1.type==2){
          rkt.damage *= 1.1;
        }
        else{
          bim1.damage *= 1.5;
        }
        player1.state -= player1.expcap/100;
        player1.grade5 += 1;
        drawstatus();
      }
      else if(mouse_y>528 && mouse_y<537 && player1.grade>player1.grade6){//as
        if(player1.type==0){
          blt.delay *= 0.9;
        }
        else if(player1.type==1){
          bim1.delay *= 0.9;
        }
        else if(player1.type==2){
          rkt.delay *= 0.9;
        }
        else{
          bim1.delay *= 0.7;
        }
        player1.state -= player1.expcap/100;
        player1.grade6 += 1;
        drawstatus();
      }
      else if(mouse_y>553 && mouse_y<563 && player1.grade>player1.grade7){//spe
        player1.spe *= 1.05;
        player1.state -= player1.expcap/100;
        player1.grade7 += 1;
        drawstatus();
      }
      else if(mouse_y>578 && player1.state*10>=player1.expcap){//EXP upgade
        player1.grade+=1;
        player1.state = 0;
        //暫定
        if(player1.type==-1){
          player1.maxhp = player1.grade*20;
          player1.hpgain = 1/30+(player1.grade-1)*0.02;
          player1.maxmp = (player1.grade+1)*40;
          player1.mpgain = 0.2+player1.grade*0.3;
          player1.spe = 3.5+player1.grade*0.5;
          player1.expcap = (player1.grade+1)*50;
          bim1.damage = (player1.grade/5+0.8)**2*1/2;
          bim1.delay = 30/(player1.grade/10+0.9);
        }
        else{
          player1.maxhp = (player1.grade+1)*50;
          player1.hpgain = 1/30+(player1.grade-1)*0.01;
          player1.maxmp = (player1.grade+1)*50;
          player1.mpgain = 0.3+player1.grade*0.2;
          player1.spe = 4+player1.grade*0.5;
          player1.expcap = (player1.grade+1)*50;
          if(player1.type==0){
            blt.damage = (player1.grade/10+0.9)**2*2/3;
            blt.delay = 30/(player1.grade/10+0.9);
          }
          else if(player1.type==1){
            bim1.damage = (player1.grade/10+0.9)**2*1/2;
            bim1.delay = 30/(player1.grade/10+0.9);
          }
          else if(player1.type==2){
            rkt.damage = (player1.grade/10+0.9)*40;
            rkt.delay = 60/(player1.grade/5+0.8)**2;
          }
        }
        drawstatus();
      }
    }
  }
});
// EventListener for Game Start
window.addEventListener("keydown", handleKeyPress);
//clickbutton button
button1.onclick = function() {
  window.location.href = 'index.html';
};

    </script>
    <div class="textContainer">
      <h1>Escape from Apocalypse</h1>
      <h2>hikaru 2023</h2>
    </div>
  </body>
</html>